Use the same pattern that fixed auth.

await fetch('/api/company', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Accept': 'application/json'
  },
  credentials: 'include',
  body: JSON.stringify(payload),
});

async function safeJson(res: Response) {
  const ct = res.headers.get('content-type') || '';
  if (!ct.includes('application/json')) {
    const text = await res.text();
    throw new Error(`Expected JSON, got ${ct}. First 120: ${text.slice(0,120)}`);
  }
  return res.json();
}

Server-side hardening (make this universal)
1) Ensure API routes run before Vite and SPA
// API first
app.use('/api/auth', authRouter);
app.use('/api/company', companyRouter); // or '/api/companies'

// Vite middleware next
app.use(viteMiddleware);

// SPA fallback last
app.use('*', (req, res) => sendIndexHtml(req, res));


If Vite or the SPA fallback runs before your /api/* routes, unknown API calls will return index.html.

2) Force JSON for all errors

Add a single JSON error handler at the very end.

app.use((err, req, res, next) => {
  const status = err.status || 500;
  const message = err.message || 'Internal error';
  // Never leak HTML
  res.status(status).json({
    success: false,
    message,
    code: err.code || undefined,
    details: err.details || undefined
  });
});


Express’s default error handler returns HTML. This replaces it.

3) Return JSON for missing API routes

Right before the error handler:

// 404 for unknown API endpoints (JSON only)
app.use('/api', (req, res) => {
  res.status(404).json({ success: false, message: `Not found: ${req.method} ${req.originalUrl}` });
});


Now, any typo like /api/company vs /api/companies still gives JSON.

4) Don’t redirect XHR to HTML

In auth guards or CSRF middleware, avoid res.redirect('/login') for /api/*. Do JSON instead.

function requireAuth(req, res, next) {
  if (!req.user) {
    return res.status(401).json({ success: false, message: 'Authentication required' });
  }
  next();
}

5) Body parsing and method checks
app.use(express.json({ limit: '2mb' })); // before routes
// In the route:
if (req.method !== 'POST') return res.status(405).json({ success: false, message: 'Method not allowed' });

6) Session cookie stays consistent

Same cookie settings you used for login/logout:

SameSite: 'lax' in dev

secure: false in dev, true only over HTTPS

Frontend sends credentials: 'include'

Sanity test for the Company route

Run these from your terminal (with server running):

# 1) Not logged in should return JSON 401
curl -i -X POST http://localhost:5000/api/company \
  -H "Content-Type: application/json" \
  -d '{"name":"Test Co"}'

# 2) Login, keep cookie
curl -i -c /tmp/sid.txt -X POST http://localhost:5000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin.healthcare","password":"admin2024"}'

# 3) Create company with cookie, expect 201 JSON
curl -i -b /tmp/sid.txt -X POST http://localhost:5000/api/company \
  -H "Content-Type: application/json" \
  -H "Accept: application/json" \
  -d '{"name":"Test Co"}'


If step 1 or 3 shows Content-Type: text/html, one of the guards above isn’t in place.

Typical route skeleton (for reference)
companyRouter.post('/', requireAuth, async (req, res, next) => {
  try {
    const { name } = req.body;
    if (!name) return res.status(400).json({ success: false, message: 'Name is required' });

    const created = await db.company.create({ data: { name, tenantId: req.user.tenantId } });
    res.status(201).json({ success: true, company: created });
  } catch (err) {
    next(err); // global JSON error handler will shape the response
  }
});