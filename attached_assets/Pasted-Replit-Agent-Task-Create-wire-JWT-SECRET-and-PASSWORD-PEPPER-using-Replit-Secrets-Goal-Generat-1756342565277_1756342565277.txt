Replit Agent Task — Create & wire JWT_SECRET and PASSWORD_PEPPER using Replit Secrets

Goal:
Generate strong secrets, store them in the Replit Secrets panel, verify they’re readable at runtime, and refuse to start if missing/weak. Do not write a .env file and do not print raw secrets.

Steps (do in order):

Generate secrets (random, strong)

Run:

node -e "console.log(require('crypto').randomBytes(32).toString('base64'))" > /tmp/JWT_SECRET.txt
node -e "console.log(require('crypto').randomBytes(64).toString('base64'))" > /tmp/PASSWORD_PEPPER.txt


Store secrets in Replit Secrets panel

Set the following environment variables in the Replit Secrets (Environment) UI programmatically if supported; otherwise provide clickable instructions:

JWT_SECRET = contents of /tmp/JWT_SECRET.txt

PASSWORD_PEPPER = contents of /tmp/PASSWORD_PEPPER.txt

Confirm they appear in process.env during runtime.

Do not commit any file with these values.

Add a runtime verification (fail fast, log fingerprints only)

Create server/secretsCheck.ts (use .js if this project is JS-only):

// server/secretsCheck.ts
import crypto from "crypto";

function shortHash(v?: string) {
  if (!v) return "missing";
  const h = crypto.createHash("sha256").update(v).digest("hex");
  return `${h.slice(0,8)}…${h.slice(-8)} (len=${v.length})`;
}

export function verifySecrets() {
  const jwt = process.env.JWT_SECRET;
  const pep = process.env.PASSWORD_PEPPER;

  if (!jwt || jwt.length < 32) {
    throw new Error("JWT_SECRET is missing or too short (need strong random).");
  }
  if (!pep || pep.length < 64) {
    throw new Error("PASSWORD_PEPPER is missing or too short (need strong random).");
  }

  // Fingerprints only — no raw secrets in logs
  console.info("[secrets] JWT_SECRET ok:", shortHash(jwt));
  console.info("[secrets] PASSWORD_PEPPER ok:", shortHash(pep));
}


In the main server entry (e.g. server/index.ts or server/index.js), at the very top add:

import { verifySecrets } from "./secretsCheck";
verifySecrets();


Add a script to quickly sanity-check

In package.json add (adjust to TS/JS toolchain):

{
  "scripts": {
    "check:secrets": "node -e \"require('./dist/secretsCheck')\" || ts-node server/secretsCheck.ts"
  }
}


If you don’t use ts-node, rely on your normal build then node dist/secretsCheck.js.

Verify without exposing values

Run:

npm run build || true
npm run check:secrets || true


Then start the app:

npm run dev || npm start


Confirm logs show lines like:

[secrets] JWT_SECRET ok: ab12cd34…ef56ab78 (len=44)
[secrets] PASSWORD_PEPPER ok: 9f00aa11…bb22cc33 (len=88)


Safeguards

Ensure no .env file is created or committed.

Ensure no console output prints the raw secret strings.

Deliverables:

server/secretsCheck.ts (or .js) created and imported in server entry.

Replit Secrets panel populated with JWT_SECRET and PASSWORD_PEPPER.

Console shows fingerprint confirmations (no raw values).

A short report listing:

The server entry file patched

The fingerprints exactly as logged (hash-only)

Confirmation that no .env file was created

Commit message (config only; no secrets):
chore(security): wire JWT_SECRET & PASSWORD_PEPPER via Replit Secrets with runtime verification