fetch

// login
await fetch('/api/auth/login', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json', 'Accept': 'application/json' },
  credentials: 'include', // IMPORTANT
  body: JSON.stringify({ username, password }),
});

// logout
await fetch('/api/auth/logout', {
  method: 'POST',
  headers: { 'Accept': 'application/json' },
  credentials: 'include', // IMPORTANT
});


axios

import axios from 'axios';
axios.defaults.withCredentials = true;
axios.defaults.headers.common['Accept'] = 'application/json';

// login
await axios.post('/api/auth/login', { username, password });

// logout
await axios.post('/api/auth/logout');


defensive JSON parse (prevents “HTML as JSON” crashes)

async function safeJson(res: Response) {
  const ct = res.headers.get('content-type') || '';
  if (!ct.includes('application/json')) {
    const text = await res.text();
    throw new Error(`Expected JSON, got ${ct}. First 120 chars: ${text.slice(0,120)}`);
  }
  return res.json();
}

Backend

Session and CORS (dev)

import session from 'express-session';
import cors from 'cors';

app.use(cors({
  origin: 'http://localhost:5000', // same origin if single-port
  credentials: true,
}));

app.use(session({
  name: 'sid',
  secret: process.env.SESSION_SECRET || 'devsecret',
  resave: false,
  saveUninitialized: false,
  cookie: {
    httpOnly: true,
    sameSite: 'lax',       // good default for same-origin dev
    secure: false,         // true only behind https
    maxAge: 1000 * 60 * 60 * 8,
  },
}));


Always return JSON on auth failures

function requireAuth(req, res, next) {
  if (!req.user) {
    return res.status(401).json({ success: false, message: 'Authentication required' });
  }
  next();
}


Middleware order

// 1) API routes first
app.use('/api/auth', authRouter);
// other /api/* routers...

// 2) then Vite middleware / static
app.use(viteMiddleware);

// 3) SPA fallback LAST
app.use('*', (req, res) => { /* send index.html */ });

Production reverse proxy (if applicable)

Make sure /api/ goes to Node, not the SPA.

location /api/ {
  proxy_pass http://127.0.0.1:5000;
  proxy_set_header Host $host;
  proxy_set_header X-Forwarded-Proto $scheme;
}
location / {
  root   /var/www/app/dist;
  try_files $uri /index.html;
}

How to prove it in 2 minutes

DevTools → Network → click /api/auth/user

If Status is 302 or Content-Type: text/html, your cookie wasn’t sent or the server redirected.

If Request Headers show Cookie: sid=… is missing, the browser didn’t include your session cookie → fix credentials/withCredentials.

Check Response Headers

On login, you should see Set-Cookie: sid=...; Path=/; SameSite=Lax.

If you don’t see it, the server isn’t setting it, or Chrome blocked it. Chrome console will show a cookie warning if blocked.

Call /api/auth/user in curl with cookie

If curl works and browser fails, it’s definitely a cookie transport issue.

Quick checklist

 Add credentials: 'include' or axios.defaults.withCredentials = true.

 Ensure session cookie flags: sameSite: 'lax', secure: false in dev.

 Ensure unauthenticated paths return JSON 401, not res.redirect.

 Confirm API routes are registered before Vite and SPA fallback.

 If deployed, fix proxy rules so /api/* hits Node, not the SPA.