import { pgTable, text, serial, integer, boolean, timestamp, jsonb, decimal } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";

// Companies table
export const companies = pgTable("companies", {
  id: text("id").primaryKey(), // UUID generated by crypto.randomUUID()
  name: text("name").notNull(),
  businessAddress: text("business_address"),
  registrationNumber: text("registration_number"),
  primaryContactName: text("primary_contact_name").notNull(),
  primaryContactEmail: text("primary_contact_email").notNull(),
  primaryContactPhone: text("primary_contact_phone"),
  customLogo: text("custom_logo"), // URL for uploaded company logo
  logoUploadedAt: timestamp("logo_uploaded_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Tenants table
export const tenants = pgTable("tenants", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  type: text("type").notNull(),
  settings: jsonb("settings").default({}),
  companyId: text("company_id").references(() => companies.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Users table with tenant association
export const users = pgTable("users", {
  id: serial("id").primaryKey(),
  username: text("username").notNull().unique(),
  password: text("password").notNull(),
  email: text("email"),
  fullName: text("full_name").notNull(),
  phone: text("phone"),
  address: text("address"),
  role: text("role").notNull().default("staff"), // admin, staff, viewer
  tenantId: integer("tenant_id").notNull().references(() => tenants.id),
  isActive: boolean("is_active").default(true),
  isFirstLogin: boolean("is_first_login").default(true),
  // Payroll information
  employmentType: text("employment_type").default("casual"), // "full-time", "part-time", "casual"
  payLevel: integer("pay_level").default(1), // 1-4
  payPoint: integer("pay_point").default(1), // 1-4
  tfn: text("tfn"), // Tax File Number
  superFund: text("super_fund"), // Superannuation fund
  superMemberNumber: text("super_member_number"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Clients table
export const clients = pgTable("clients", {
  id: serial("id").primaryKey(),
  clientId: text("client_id").notNull().unique(), // Auto-generated unique ID
  firstName: text("first_name").notNull(),
  lastName: text("last_name").notNull(),
  fullName: text("full_name").notNull(),
  ndisNumber: text("ndis_number").notNull(),
  dateOfBirth: timestamp("date_of_birth").notNull(),
  address: text("address"),
  emergencyContactName: text("emergency_contact_name"),
  emergencyContactPhone: text("emergency_contact_phone"),
  ndisGoals: text("ndis_goals"),
  likesPreferences: text("likes_preferences"),
  dislikesAversions: text("dislikes_aversions"),
  allergiesMedicalAlerts: text("allergies_medical_alerts"),
  primaryDiagnosis: text("primary_diagnosis"),
  tenantId: integer("tenant_id").notNull().references(() => tenants.id),
  companyId: text("company_id").notNull(), // For tenant isolation
  createdBy: integer("created_by").notNull().references(() => users.id),
  isActive: boolean("is_active").default(true),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Form templates table
export const formTemplates = pgTable("form_templates", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  description: text("description"),
  fields: jsonb("fields").notNull().default([]),
  tenantId: integer("tenant_id").notNull().references(() => tenants.id),
  createdBy: integer("created_by").notNull().references(() => users.id),
  isActive: boolean("is_active").default(true),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Form submissions table
export const formSubmissions = pgTable("form_submissions", {
  id: serial("id").primaryKey(),
  templateId: integer("template_id").notNull().references(() => formTemplates.id),
  clientId: integer("client_id").references(() => clients.id),
  submittedBy: integer("submitted_by").notNull().references(() => users.id),
  data: jsonb("data").notNull().default({}),
  status: text("status").notNull().default("completed"), // pending, completed
  tenantId: integer("tenant_id").notNull().references(() => tenants.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Shifts table
export const shifts = pgTable("shifts", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id), // Made nullable for unassigned shifts
  clientId: integer("client_id").references(() => clients.id),
  title: text("title"),
  description: text("description"),
  startTime: timestamp("start_time").notNull(),
  endTime: timestamp("end_time"),
  status: text("status").default("assigned"), // assigned, requested, in-progress, completed, cancelled
  location: text("location"),
  latitude: decimal("latitude", { precision: 10, scale: 8 }),
  longitude: decimal("longitude", { precision: 11, scale: 8 }),
  building: text("building"),
  floor: text("floor"),
  // Shift tracking fields
  startTimestamp: timestamp("start_timestamp"),
  endTimestamp: timestamp("end_timestamp"),
  startLocation: text("start_location"),
  endLocation: text("end_location"),
  handoverReceivedFromStaffId: integer("handover_received_from_staff_id").references(() => users.id),
  handoverGivenToStaffId: integer("handover_given_to_staff_id").references(() => users.id),
  handoverNotesIn: text("handover_notes_in"),
  handoverNotesOut: text("handover_notes_out"),
  // NDIS Budget tracking fields
  fundingCategory: text("funding_category"), // "SIL", "CommunityAccess", "CapacityBuilding"
  staffRatio: text("staff_ratio"), // "1:1", "1:2", "1:3", "1:4", "2:1"
  isActive: boolean("is_active").default(true),
  seriesId: text("series_id"), // For grouping recurring shifts
  isRecurring: boolean("is_recurring").default(false),
  recurringPattern: text("recurring_pattern"), // "weekly", "fortnightly", "monthly"
  recurringDays: jsonb("recurring_days"), // Array of selected days for recurring shifts
  shiftStartDate: timestamp("shift_start_date"), // When recurring shifts should start
  shiftStartTime: text("shift_start_time"), // Time format like "09:00"
  shiftEndTime: text("shift_end_time"), // Time format like "17:00"
  tenantId: integer("tenant_id").notNull().references(() => tenants.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Shift Cancellations table for audit logging
export const shiftCancellations = pgTable("shift_cancellations", {
  id: serial("id").primaryKey(),
  shiftId: integer("shift_id").notNull().references(() => shifts.id),
  cancelledByUserId: integer("cancelled_by_user_id").notNull().references(() => users.id),
  cancelledByUserName: text("cancelled_by_user_name").notNull(),
  shiftTitle: text("shift_title"),
  shiftStartTime: timestamp("shift_start_time").notNull(),
  shiftEndTime: timestamp("shift_end_time"),
  clientName: text("client_name"),
  cancellationType: text("cancellation_type").notNull(), // "immediate" or "requested"
  cancellationReason: text("cancellation_reason"),
  hoursNotice: integer("hours_notice").notNull(), // Hours between cancellation and shift start
  approvedByUserId: integer("approved_by_user_id").references(() => users.id), // For requested cancellations
  approvedByUserName: text("approved_by_user_name"),
  approvedAt: timestamp("approved_at"),
  tenantId: integer("tenant_id").notNull().references(() => tenants.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Cancellation Requests table for pending approvals
export const cancellationRequests = pgTable("cancellation_requests", {
  id: serial("id").primaryKey(),
  shiftId: integer("shift_id").notNull().references(() => shifts.id),
  requestedByUserId: integer("requested_by_user_id").notNull().references(() => users.id),
  requestedByUserName: text("requested_by_user_name").notNull(),
  shiftTitle: text("shift_title"),
  shiftStartTime: timestamp("shift_start_time").notNull(),
  shiftEndTime: timestamp("shift_end_time"),
  clientName: text("client_name"),
  requestReason: text("request_reason"),
  hoursNotice: integer("hours_notice").notNull(),
  status: text("status").notNull().default("pending"), // "pending", "approved", "denied"
  reviewedByUserId: integer("reviewed_by_user_id").references(() => users.id),
  reviewedByUserName: text("reviewed_by_user_name"),
  reviewedAt: timestamp("reviewed_at"),
  reviewNotes: text("review_notes"),
  tenantId: integer("tenant_id").notNull().references(() => tenants.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Staff Availability table
export const staffAvailability = pgTable("staff_availability", {
  id: serial("id").primaryKey(),
  availabilityId: text("availability_id").notNull().unique(),
  userId: integer("user_id").notNull().references(() => users.id),
  companyId: integer("company_id").notNull().references(() => tenants.id),
  availability: jsonb("availability").notNull(), // {Monday: ["AM", "PM"], Tuesday: ["Active Night"], ...}
  patternName: text("pattern_name"), // For saved quick patterns
  isQuickPattern: boolean("is_quick_pattern").default(false),
  overrideByManager: boolean("override_by_manager").default(false),
  isActive: boolean("is_active").default(true),
  tenantId: integer("tenant_id").notNull().references(() => tenants.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Case Notes table
export const caseNotes = pgTable("case_notes", {
  id: serial("id").primaryKey(),
  clientId: integer("client_id").notNull().references(() => clients.id),
  userId: integer("user_id").notNull().references(() => users.id),
  tenantId: integer("tenant_id").notNull().references(() => tenants.id),
  title: text("title").notNull(),
  content: text("content").notNull(),
  type: text("type").notNull().default("standard"), // standard, incident, medication
  category: text("category").notNull().default("Progress Note"),
  priority: text("priority").notNull().default("normal"), // normal, high, urgent
  tags: text("tags").array().default([]),
  linkedShiftId: integer("linked_shift_id").references(() => shifts.id),
  attachments: jsonb("attachments").default([]),
  caseNoteTags: jsonb("case_note_tags").default({}), // { incident: { occurred: boolean, refNumber?: string, lodged?: boolean }, medication: { status: string, recordLogged?: boolean } }
  spellCheckCount: integer("spell_check_count").default(0),
  incidentData: jsonb("incident_data"),
  medicationData: jsonb("medication_data"),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

// Hourly Observations table
export const hourlyObservations = pgTable("hourly_observations", {
  id: serial("id").primaryKey(),
  clientId: integer("client_id").notNull().references(() => clients.id),
  userId: integer("user_id").notNull().references(() => users.id),
  tenantId: integer("tenant_id").notNull().references(() => tenants.id),
  observationType: text("observation_type").notNull(), // behaviour, adl
  subtype: text("subtype"), // specific subcategory based on type (for ADL)
  notes: text("notes"), // for ADL observations
  // Star chart fields for behaviour observations
  settings: text("settings"), // environmental settings description
  settingsRating: integer("settings_rating"), // 1-5 rating
  time: text("time"), // timing factors description
  timeRating: integer("time_rating"), // 1-5 rating
  antecedents: text("antecedents"), // what happened before description
  antecedentsRating: integer("antecedents_rating"), // 1-5 rating
  response: text("response"), // how incident was handled description
  responseRating: integer("response_rating"), // 1-5 rating
  timestamp: timestamp("timestamp").notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Medication Plans table
export const medicationPlans = pgTable("medication_plans", {
  id: serial("id").primaryKey(),
  clientId: integer("client_id").notNull().references(() => clients.id),
  medicationName: text("medication_name").notNull(),
  dosage: text("dosage").notNull(),
  frequency: text("frequency").notNull(),
  route: text("route").notNull(), // oral, injection, topical, etc.
  timeOfDay: text("time_of_day"),
  startDate: timestamp("start_date").notNull(),
  endDate: timestamp("end_date"),
  prescribedBy: text("prescribed_by").notNull(),
  instructions: text("instructions"),
  sideEffects: text("side_effects").array().default([]),
  status: text("status").notNull().default("active"), // active, inactive, discontinued
  createdBy: integer("created_by").notNull().references(() => users.id),
  tenantId: integer("tenant_id").notNull().references(() => tenants.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Medication Records table
export const medicationRecords = pgTable("medication_records", {
  id: serial("id").primaryKey(),
  medicationPlanId: integer("medication_plan_id").references(() => medicationPlans.id), // Made nullable for manual entries
  clientId: integer("client_id").notNull().references(() => clients.id),
  administeredBy: integer("administered_by").notNull().references(() => users.id),
  medicationName: text("medication_name"), // Added for direct medication name - nullable initially
  scheduledTime: timestamp("scheduled_time"),
  actualTime: timestamp("actual_time"),
  dateTime: timestamp("date_time"), // New field for administration date/time - nullable initially
  timeOfDay: text("time_of_day"), // Morning, Afternoon, Night - nullable initially
  route: text("route"), // Oral, Injection, Topical, Other - nullable initially
  status: text("status"), // Administered, Refused, Missed - nullable initially
  result: text("result").notNull(), // administered, refused, missed, delayed (legacy field)
  notes: text("notes"),
  refusalReason: text("refusal_reason"),
  wasWitnessed: boolean("was_witnessed").default(false),
  attachmentBeforeUrl: text("attachment_before_url"), // Photo before administration
  attachmentAfterUrl: text("attachment_after_url"), // Photo after administration
  tenantId: integer("tenant_id").notNull().references(() => tenants.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Activity logs table
export const activityLogs = pgTable("activity_logs", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  action: text("action").notNull(),
  resourceType: text("resource_type").notNull(),
  resourceId: integer("resource_id"),
  description: text("description").notNull(),
  metadata: jsonb("metadata").default({}),
  tenantId: integer("tenant_id").notNull().references(() => tenants.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Incident Reports table
export const incidentReports = pgTable("incident_reports", {
  id: serial("id").primaryKey(),
  incidentId: text("incident_id").notNull().unique(),
  clientId: integer("client_id").notNull().references(() => clients.id),
  staffId: integer("staff_id").notNull().references(() => users.id),
  dateTime: timestamp("date_time").notNull(),
  location: text("location").notNull(),
  witnessName: text("witness_name"),
  witnessPhone: text("witness_phone"),
  types: text("types").array().notNull(),
  isNDISReportable: boolean("is_ndis_reportable").default(false),
  triggers: jsonb("triggers").default([]), // [{ label: string, notes?: string }]
  intensityRating: integer("intensity_rating").notNull(),
  staffResponses: jsonb("staff_responses").default([]), // [{ label: string, notes?: string }]
  description: text("description").notNull(),
  externalRef: text("external_ref"),
  status: text("status").notNull().default("Open"), // "Open", "Closed"
  tenantId: integer("tenant_id").notNull().references(() => tenants.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Incident Closures table
export const incidentClosures = pgTable("incident_closures", {
  id: serial("id").primaryKey(),
  incidentId: text("incident_id").notNull().unique(),
  closedBy: integer("closed_by").notNull().references(() => users.id),
  closureDate: timestamp("closure_date").notNull(),
  controlReview: boolean("control_review").notNull(),
  improvements: text("improvements"),
  implemented: boolean("implemented").notNull(),
  controlLevel: text("control_level").notNull(), // "Elimination", "Engineering", "Behavioural", "Admin", "PPE", "None"
  wasLTI: text("was_lti").notNull(), // "yes", "no", "NA"
  hazard: text("hazard").notNull(), // "Behavioural", "Medical", "Environmental", "Other"
  severity: text("severity").notNull(), // "Low", "Medium", "High", "Critical"
  externalNotice: boolean("external_notice").notNull(),
  participantContext: text("participant_context").notNull(), // "yes", "no", "NA"
  supportPlanAvailable: text("support_plan_available").notNull(), // "yes", "no", "NA"
  reviewType: text("review_type").notNull(), // "Root Cause", "Case Conference", "Support Team Review", "Corrective Action", "No Further Action"
  outcome: text("outcome"),
  attachments: jsonb("attachments").default([]),
  tenantId: integer("tenant_id").notNull().references(() => tenants.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Relations
export const companiesRelations = relations(companies, ({ many }) => ({
  tenants: many(tenants),
}));

export const tenantsRelations = relations(tenants, ({ one, many }) => ({
  company: one(companies, {
    fields: [tenants.companyId],
    references: [companies.id],
  }),
  users: many(users),
  clients: many(clients),
  formTemplates: many(formTemplates),
  formSubmissions: many(formSubmissions),
  shifts: many(shifts),
  staffAvailability: many(staffAvailability),
  caseNotes: many(caseNotes),
  activityLogs: many(activityLogs),
}));

export const usersRelations = relations(users, ({ one, many }) => ({
  tenant: one(tenants, {
    fields: [users.tenantId],
    references: [tenants.id],
  }),
  createdClients: many(clients),
  createdFormTemplates: many(formTemplates),
  formSubmissions: many(formSubmissions),
  shifts: many(shifts),
  availability: many(staffAvailability),
  caseNotes: many(caseNotes),
  activityLogs: many(activityLogs),
  observations: many(hourlyObservations),
  createdMedicationPlans: many(medicationPlans),
  medicationRecords: many(medicationRecords),
  incidentReports: many(incidentReports),
  incidentClosures: many(incidentClosures),
}));

export const clientsRelations = relations(clients, ({ one, many }) => ({
  tenant: one(tenants, {
    fields: [clients.tenantId],
    references: [tenants.id],
  }),
  createdBy: one(users, {
    fields: [clients.createdBy],
    references: [users.id],
  }),
  formSubmissions: many(formSubmissions),
  caseNotes: many(caseNotes),
  shifts: many(shifts),
  observations: many(hourlyObservations),
  medicationPlans: many(medicationPlans),
  medicationRecords: many(medicationRecords),
  incidentReports: many(incidentReports),
}));

export const formTemplatesRelations = relations(formTemplates, ({ one, many }) => ({
  tenant: one(tenants, {
    fields: [formTemplates.tenantId],
    references: [tenants.id],
  }),
  createdBy: one(users, {
    fields: [formTemplates.createdBy],
    references: [users.id],
  }),
  submissions: many(formSubmissions),
}));

export const formSubmissionsRelations = relations(formSubmissions, ({ one }) => ({
  template: one(formTemplates, {
    fields: [formSubmissions.templateId],
    references: [formTemplates.id],
  }),
  client: one(clients, {
    fields: [formSubmissions.clientId],
    references: [clients.id],
  }),
  submittedBy: one(users, {
    fields: [formSubmissions.submittedBy],
    references: [users.id],
  }),
  tenant: one(tenants, {
    fields: [formSubmissions.tenantId],
    references: [tenants.id],
  }),
}));

export const shiftsRelations = relations(shifts, ({ one, many }) => ({
  user: one(users, {
    fields: [shifts.userId],
    references: [users.id],
  }),
  client: one(clients, {
    fields: [shifts.clientId],
    references: [clients.id],
  }),
  tenant: one(tenants, {
    fields: [shifts.tenantId],
    references: [tenants.id],
  }),
  linkedCaseNotes: many(caseNotes),
}));

export const caseNotesRelations = relations(caseNotes, ({ one }) => ({
  client: one(clients, {
    fields: [caseNotes.clientId],
    references: [clients.id],
  }),
  user: one(users, {
    fields: [caseNotes.userId],
    references: [users.id],
  }),
  tenant: one(tenants, {
    fields: [caseNotes.tenantId],
    references: [tenants.id],
  }),
  linkedShift: one(shifts, {
    fields: [caseNotes.linkedShiftId],
    references: [shifts.id],
  }),
}));

export const staffAvailabilityRelations = relations(staffAvailability, ({ one }) => ({
  user: one(users, {
    fields: [staffAvailability.userId],
    references: [users.id],
  }),
  company: one(tenants, {
    fields: [staffAvailability.companyId],
    references: [tenants.id],
  }),
}));

export const hourlyObservationsRelations = relations(hourlyObservations, ({ one }) => ({
  client: one(clients, {
    fields: [hourlyObservations.clientId],
    references: [clients.id],
  }),
  user: one(users, {
    fields: [hourlyObservations.userId],
    references: [users.id],
  }),
  tenant: one(tenants, {
    fields: [hourlyObservations.tenantId],
    references: [tenants.id],
  }),
}));

export const activityLogsRelations = relations(activityLogs, ({ one }) => ({
  user: one(users, {
    fields: [activityLogs.userId],
    references: [users.id],
  }),
  tenant: one(tenants, {
    fields: [activityLogs.tenantId],
    references: [tenants.id],
  }),
}));

export const medicationPlansRelations = relations(medicationPlans, ({ one, many }) => ({
  client: one(clients, {
    fields: [medicationPlans.clientId],
    references: [clients.id],
  }),
  createdBy: one(users, {
    fields: [medicationPlans.createdBy],
    references: [users.id],
  }),
  tenant: one(tenants, {
    fields: [medicationPlans.tenantId],
    references: [tenants.id],
  }),
  records: many(medicationRecords),
}));

export const medicationRecordsRelations = relations(medicationRecords, ({ one }) => ({
  medicationPlan: one(medicationPlans, {
    fields: [medicationRecords.medicationPlanId],
    references: [medicationPlans.id],
  }),
  client: one(clients, {
    fields: [medicationRecords.clientId],
    references: [clients.id],
  }),
  administeredBy: one(users, {
    fields: [medicationRecords.administeredBy],
    references: [users.id],
  }),
  tenant: one(tenants, {
    fields: [medicationRecords.tenantId],
    references: [tenants.id],
  }),
}));

export const incidentReportsRelations = relations(incidentReports, ({ one }) => ({
  client: one(clients, {
    fields: [incidentReports.clientId],
    references: [clients.id],
  }),
  staff: one(users, {
    fields: [incidentReports.staffId],
    references: [users.id],
  }),
  tenant: one(tenants, {
    fields: [incidentReports.tenantId],
    references: [tenants.id],
  }),
}));

export const incidentClosuresRelations = relations(incidentClosures, ({ one }) => ({
  closedBy: one(users, {
    fields: [incidentClosures.closedBy],
    references: [users.id],
  }),
  tenant: one(tenants, {
    fields: [incidentClosures.tenantId],
    references: [tenants.id],
  }),
}));

// Staff Messages table
export const staffMessages = pgTable("staff_messages", {
  id: serial("id").primaryKey(),
  senderId: integer("sender_id").notNull().references(() => users.id),
  recipientIds: integer("recipient_ids").array().notNull(),
  subject: text("subject").notNull(),
  body: text("body").notNull(),
  messageType: text("message_type").notNull().default("quick"), // quick, urgent
  attachments: jsonb("attachments").default([]),
  replyToId: integer("reply_to_id"),
  isRead: jsonb("is_read").default({}), // Object mapping userId to read status
  tenantId: integer("tenant_id").notNull().references(() => tenants.id),
  createdAt: timestamp("created_at").notNull().defaultNow(),
  updatedAt: timestamp("updated_at").notNull().defaultNow(),
});

export const staffMessagesRelations = relations(staffMessages, ({ one }) => ({
  sender: one(users, {
    fields: [staffMessages.senderId],
    references: [users.id],
  }),
  tenant: one(tenants, {
    fields: [staffMessages.tenantId],
    references: [tenants.id],
  }),
}));

// Hour Allocations table
export const hourAllocations = pgTable("hour_allocations", {
  id: serial("id").primaryKey(),
  staffId: integer("staff_id").notNull().references(() => users.id),
  tenantId: integer("tenant_id").notNull().references(() => tenants.id),
  allocationPeriod: text("allocation_period").notNull(), // "weekly" | "fortnightly"
  maxHours: decimal("max_hours", { precision: 5, scale: 2 }).notNull(),
  hoursUsed: decimal("hours_used", { precision: 5, scale: 2 }).default("0").notNull(),
  remainingHours: decimal("remaining_hours", { precision: 5, scale: 2 }).notNull(),
  isActive: boolean("is_active").default(true),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const hourAllocationsRelations = relations(hourAllocations, ({ one }) => ({
  staff: one(users, {
    fields: [hourAllocations.staffId],
    references: [users.id],
  }),
  tenant: one(tenants, {
    fields: [hourAllocations.tenantId],
    references: [tenants.id],
  }),
}));

// Custom Roles table - for dynamically created roles
export const customRoles = pgTable("custom_roles", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(), // e.g., "Senior Support Worker", "Clinical Coordinator"
  displayName: text("display_name").notNull(),
  description: text("description"),
  basedOnRole: text("based_on_role"), // Reference to built-in role it extends
  isActive: boolean("is_active").default(true),
  tenantId: integer("tenant_id").notNull().references(() => tenants.id),
  createdBy: integer("created_by").notNull().references(() => users.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Custom Permissions table - for permission overrides and custom role permissions
export const customPermissions = pgTable("custom_permissions", {
  id: serial("id").primaryKey(),
  roleId: integer("role_id").references(() => customRoles.id), // For custom roles
  builtInRole: text("built_in_role"), // For overriding built-in roles
  module: text("module").notNull(), // e.g., "clients", "shifts", "medications"
  actions: jsonb("actions").notNull(), // Array of allowed actions
  scope: text("scope").notNull(), // "global", "company", "assigned"
  conditions: jsonb("conditions"), // Additional conditions for permission
  isOverride: boolean("is_override").default(false), // True if overriding default permission
  tenantId: integer("tenant_id").notNull().references(() => tenants.id),
  createdBy: integer("created_by").notNull().references(() => users.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// User Role Assignments table - for assigning custom roles to users
export const userRoleAssignments = pgTable("user_role_assignments", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id),
  roleId: integer("role_id").references(() => customRoles.id), // Custom role
  builtInRole: text("built_in_role"), // Built-in role override
  assignedBy: integer("assigned_by").notNull().references(() => users.id),
  assignedAt: timestamp("assigned_at").defaultNow().notNull(),
  expiresAt: timestamp("expires_at"), // Optional expiration
  isActive: boolean("is_active").default(true),
  tenantId: integer("tenant_id").notNull().references(() => tenants.id),
});

// Notifications table
export const notifications = pgTable("notifications", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").notNull().references(() => users.id, { onDelete: "cascade" }),
  tenantId: integer("tenant_id").notNull().references(() => tenants.id, { onDelete: "cascade" }),
  type: text("type").notNull(), // "admin_request", "shift_assignment", "due_task", "message", "available_shift", "timesheet_submitted"
  title: text("title").notNull(),
  message: text("message").notNull(),
  resourceType: text("resource_type"), // "shift", "message", "timesheet", "case_note", etc.
  resourceId: integer("resource_id"), // ID of the related resource
  isRead: boolean("is_read").default(false).notNull(),
  priority: text("priority").default("normal").notNull(), // "low", "normal", "high", "urgent"
  createdAt: timestamp("created_at").defaultNow().notNull(),
  readAt: timestamp("read_at"),
});

// Relations for new tables
export const customRolesRelations = relations(customRoles, ({ one, many }) => ({
  tenant: one(tenants, {
    fields: [customRoles.tenantId],
    references: [tenants.id],
  }),
  createdBy: one(users, {
    fields: [customRoles.createdBy],
    references: [users.id],
  }),
  permissions: many(customPermissions),
  assignments: many(userRoleAssignments),
}));

export const customPermissionsRelations = relations(customPermissions, ({ one }) => ({
  role: one(customRoles, {
    fields: [customPermissions.roleId],
    references: [customRoles.id],
  }),
  tenant: one(tenants, {
    fields: [customPermissions.tenantId],
    references: [tenants.id],
  }),
  createdBy: one(users, {
    fields: [customPermissions.createdBy],
    references: [users.id],
  }),
}));

export const userRoleAssignmentsRelations = relations(userRoleAssignments, ({ one }) => ({
  user: one(users, {
    fields: [userRoleAssignments.userId],
    references: [users.id],
  }),
  role: one(customRoles, {
    fields: [userRoleAssignments.roleId],
    references: [customRoles.id],
  }),
  assignedBy: one(users, {
    fields: [userRoleAssignments.assignedBy],
    references: [users.id],
  }),
  tenant: one(tenants, {
    fields: [userRoleAssignments.tenantId],
    references: [tenants.id],
  }),
}));

export const notificationsRelations = relations(notifications, ({ one }) => ({
  user: one(users, {
    fields: [notifications.userId],
    references: [users.id],
  }),
  tenant: one(tenants, {
    fields: [notifications.tenantId],
    references: [tenants.id],
  }),
}));

// Insert schemas
export const insertCompanySchema = createInsertSchema(companies).omit({
  id: true,
  createdAt: true,
  logoUploadedAt: true,
});

export const insertTenantSchema = createInsertSchema(tenants).omit({
  id: true,
  createdAt: true,
});

export const insertUserSchema = createInsertSchema(users).omit({
  id: true,
  createdAt: true,
});

export const insertClientSchema = createInsertSchema(clients).omit({
  id: true,
  clientId: true,
  fullName: true,
  createdAt: true,
  updatedAt: true,
}).extend({
  firstName: z.string().min(1, "First name is required"),
  lastName: z.string().min(1, "Last name is required"),
  ndisNumber: z.string().min(1, "NDIS number is required"),
  dateOfBirth: z.coerce.date({ required_error: "Date of birth is required" }),
});

export const insertFormTemplateSchema = createInsertSchema(formTemplates).omit({
  id: true,
  createdAt: true,
});

export const insertFormSubmissionSchema = createInsertSchema(formSubmissions).omit({
  id: true,
  createdAt: true,
});

export const insertShiftSchema = createInsertSchema(shifts).omit({
  id: true,
  createdAt: true,
}).extend({
  fundingCategory: z.enum(["SIL", "CommunityAccess", "CapacityBuilding"]).optional(),
  staffRatio: z.enum(["1:1", "1:2", "1:3", "1:4", "2:1"]).optional(),
});

export const insertStaffAvailabilitySchema = createInsertSchema(staffAvailability).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertCaseNoteSchema = createInsertSchema(caseNotes).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertHourlyObservationSchema = createInsertSchema(hourlyObservations).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
}).extend({
  observationType: z.enum(["behaviour", "adl"]),
  // Star chart fields for behaviour observations
  settings: z.string().optional(),
  settingsRating: z.number().min(1).max(5).optional(),
  time: z.string().optional(),
  timeRating: z.number().min(1).max(5).optional(),
  antecedents: z.string().optional(),
  antecedentsRating: z.number().min(1).max(5).optional(),
  response: z.string().optional(),
  responseRating: z.number().min(1).max(5).optional(),
  // ADL fields
  subtype: z.string().optional(),
  notes: z.string().optional(),
});

export const insertActivityLogSchema = createInsertSchema(activityLogs).omit({
  id: true,
  createdAt: true,
});

export const insertMedicationPlanSchema = createInsertSchema(medicationPlans).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
}).extend({
  startDate: z.coerce.date(),
  endDate: z.string().optional().transform((val) => {
    if (!val || val === "") return undefined;
    return new Date(val);
  }),
});

export const insertMedicationRecordSchema = createInsertSchema(medicationRecords).omit({
  id: true,
  createdAt: true,
});

export const insertIncidentReportSchema = createInsertSchema(incidentReports).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertIncidentClosureSchema = createInsertSchema(incidentClosures).omit({
  id: true,
  createdAt: true,
});

export const insertStaffMessageSchema = createInsertSchema(staffMessages).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertHourAllocationSchema = createInsertSchema(hourAllocations).omit({
  id: true,
  hoursUsed: true,
  remainingHours: true,
  createdAt: true,
  updatedAt: true,
}).extend({
  maxHours: z.number().min(1, "Max hours must be at least 1").max(744, "Max hours cannot exceed 744 hours per month"),
  allocationPeriod: z.enum(["weekly", "fortnightly", "monthly"], { required_error: "Allocation period is required" }),
});

export const insertCustomRoleSchema = createInsertSchema(customRoles).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
  tenantId: true,  // Backend will add this
  createdBy: true, // Backend will add this
}).extend({
  name: z.string().min(2, "Role name must be at least 2 characters").max(50, "Role name cannot exceed 50 characters"),
  displayName: z.string().min(2, "Display name must be at least 2 characters").max(100, "Display name cannot exceed 100 characters"),
  basedOnRole: z.enum(["SupportWorker", "TeamLeader", "Coordinator", "Admin"]).optional(),
  description: z.string().optional().or(z.literal("")),
});

export const insertCustomPermissionSchema = createInsertSchema(customPermissions).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
}).extend({
  actions: z.array(z.string()).min(1, "At least one action is required"),
  scope: z.enum(["global", "company", "assigned"], { required_error: "Scope is required" }),
});

export const insertUserRoleAssignmentSchema = createInsertSchema(userRoleAssignments).omit({
  id: true,
  assignedAt: true,
}).extend({
  expiresAt: z.date().optional(),
});

export const insertNotificationSchema = createInsertSchema(notifications).omit({
  id: true,
  createdAt: true,
  readAt: true,
});

// Types
export type Company = typeof companies.$inferSelect;
export type InsertCompany = z.infer<typeof insertCompanySchema>;

export type Tenant = typeof tenants.$inferSelect;
export type InsertTenant = z.infer<typeof insertTenantSchema>;

export type User = typeof users.$inferSelect;
export type InsertUser = z.infer<typeof insertUserSchema>;

export type Client = typeof clients.$inferSelect;
export type InsertClient = z.infer<typeof insertClientSchema>;

export type FormTemplate = typeof formTemplates.$inferSelect;
export type InsertFormTemplate = z.infer<typeof insertFormTemplateSchema>;

export type FormSubmission = typeof formSubmissions.$inferSelect;
export type InsertFormSubmission = z.infer<typeof insertFormSubmissionSchema>;

export type Shift = typeof shifts.$inferSelect;
export type InsertShift = z.infer<typeof insertShiftSchema>;

export type StaffAvailability = typeof staffAvailability.$inferSelect;
export type InsertStaffAvailability = z.infer<typeof insertStaffAvailabilitySchema>;

export type CaseNote = typeof caseNotes.$inferSelect;
export type InsertCaseNote = z.infer<typeof insertCaseNoteSchema>;

export type HourlyObservation = typeof hourlyObservations.$inferSelect;
export type InsertHourlyObservation = z.infer<typeof insertHourlyObservationSchema>;

export type ActivityLog = typeof activityLogs.$inferSelect;
export type InsertActivityLog = z.infer<typeof insertActivityLogSchema>;

export type MedicationPlan = typeof medicationPlans.$inferSelect;
export type InsertMedicationPlan = z.infer<typeof insertMedicationPlanSchema>;

export type MedicationRecord = typeof medicationRecords.$inferSelect;
export type InsertMedicationRecord = z.infer<typeof insertMedicationRecordSchema>;

export type IncidentReport = typeof incidentReports.$inferSelect;
export type InsertIncidentReport = z.infer<typeof insertIncidentReportSchema>;

export type IncidentClosure = typeof incidentClosures.$inferSelect;
export type InsertIncidentClosure = z.infer<typeof insertIncidentClosureSchema>;

export type StaffMessage = typeof staffMessages.$inferSelect;
export type InsertStaffMessage = z.infer<typeof insertStaffMessageSchema>;

export type HourAllocation = typeof hourAllocations.$inferSelect;
export type InsertHourAllocation = z.infer<typeof insertHourAllocationSchema>;

export type CustomRole = typeof customRoles.$inferSelect;
export type InsertCustomRole = z.infer<typeof insertCustomRoleSchema>;

export type CustomPermission = typeof customPermissions.$inferSelect;
export type InsertCustomPermission = z.infer<typeof insertCustomPermissionSchema>;

export type UserRoleAssignment = typeof userRoleAssignments.$inferSelect;
export type InsertUserRoleAssignment = z.infer<typeof insertUserRoleAssignmentSchema>;

export type Notification = typeof notifications.$inferSelect;
export type InsertNotification = z.infer<typeof insertNotificationSchema>;

export type ShiftCancellation = typeof shiftCancellations.$inferSelect;
export type InsertShiftCancellation = typeof shiftCancellations.$inferInsert;

export type CancellationRequest = typeof cancellationRequests.$inferSelect;
export type InsertCancellationRequest = typeof cancellationRequests.$inferInsert;



// Relations for cancellation tables
export const shiftCancellationsRelations = relations(shiftCancellations, ({ one }) => ({
  shift: one(shifts, {
    fields: [shiftCancellations.shiftId],
    references: [shifts.id],
  }),
  cancelledByUser: one(users, {
    fields: [shiftCancellations.cancelledByUserId],
    references: [users.id],
  }),
  approvedByUser: one(users, {
    fields: [shiftCancellations.approvedByUserId],
    references: [users.id],
  }),
  tenant: one(tenants, {
    fields: [shiftCancellations.tenantId],
    references: [tenants.id],
  }),
}));

export const cancellationRequestsRelations = relations(cancellationRequests, ({ one }) => ({
  shift: one(shifts, {
    fields: [cancellationRequests.shiftId],
    references: [shifts.id],
  }),
  requestedByUser: one(users, {
    fields: [cancellationRequests.requestedByUserId],
    references: [users.id],
  }),
  reviewedByUser: one(users, {
    fields: [cancellationRequests.reviewedByUserId],
    references: [users.id],
  }),
  tenant: one(tenants, {
    fields: [cancellationRequests.tenantId],
    references: [tenants.id],
  }),
}));

// Shift Cancellation schemas
export const insertShiftCancellationSchema = createInsertSchema(shiftCancellations).omit({
  id: true,
  createdAt: true,
});

export const insertCancellationRequestSchema = createInsertSchema(cancellationRequests).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});



// Task Board Tasks table
export const taskBoardTasks = pgTable("task_board_tasks", {
  id: serial("id").primaryKey(),
  tenantId: integer("tenant_id").notNull().references(() => tenants.id),
  title: text("title").notNull(),
  description: text("description"),
  status: text("status").notNull().default("todo"), // "todo" | "in-progress" | "done"
  dueDateTime: timestamp("due_date_time"),
  assignedToUserId: integer("assigned_to_user_id").references(() => users.id),
  createdByUserId: integer("created_by_user_id").notNull().references(() => users.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const taskBoardTasksRelations = relations(taskBoardTasks, ({ one }) => ({
  tenant: one(tenants, {
    fields: [taskBoardTasks.tenantId],
    references: [tenants.id],
  }),
  assignedTo: one(users, {
    fields: [taskBoardTasks.assignedToUserId],
    references: [users.id],
  }),
  createdBy: one(users, {
    fields: [taskBoardTasks.createdByUserId],
    references: [users.id],
  }),
}));

export const insertTaskBoardTaskSchema = createInsertSchema(taskBoardTasks).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
  tenantId: true,
  createdByUserId: true,
}).extend({
  title: z.string().min(1, "Title is required").max(200, "Title cannot exceed 200 characters"),
  description: z.string().optional(),
  status: z.enum(["todo", "in-progress", "done"]),
  dueDateTime: z.date().optional(),
});

export type TaskBoardTask = typeof taskBoardTasks.$inferSelect;
export type InsertTaskBoardTask = z.infer<typeof insertTaskBoardTaskSchema>;

// NDIS Pricing table
export const ndisPricing = pgTable("ndis_pricing", {
  id: serial("id").primaryKey(),
  tenantId: integer("tenant_id").notNull().references(() => tenants.id),
  shiftType: text("shift_type").notNull(), // "AM", "PM", "ActiveNight", "Sleepover"
  ratio: text("ratio").notNull(), // "1:1", "1:2", "1:3", "1:4", "2:1"
  rate: decimal("rate", { precision: 10, scale: 2 }).notNull(),
  isActive: boolean("is_active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const ndisPricingRelations = relations(ndisPricing, ({ one }) => ({
  tenant: one(tenants, {
    fields: [ndisPricing.tenantId],
    references: [tenants.id],
  }),
}));

export const insertNdisPricingSchema = createInsertSchema(ndisPricing).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
  tenantId: true,
}).extend({
  shiftType: z.enum(["AM", "PM", "ActiveNight", "Sleepover"]),
  ratio: z.enum(["1:1", "1:2", "1:3", "1:4", "2:1"]),
  rate: z.number().positive("Rate must be positive"),
});

export type NdisPricing = typeof ndisPricing.$inferSelect;
export type InsertNdisPricing = z.infer<typeof insertNdisPricingSchema>;

// NDIS Budgets table
export const ndisBudgets = pgTable("ndis_budgets", {
  id: serial("id").primaryKey(),
  clientId: integer("client_id").notNull().references(() => clients.id),
  tenantId: integer("tenant_id").notNull().references(() => tenants.id),
  
  // SIL Category
  silTotal: decimal("sil_total", { precision: 12, scale: 2 }).default("0").notNull(),
  silRemaining: decimal("sil_remaining", { precision: 12, scale: 2 }).default("0").notNull(),
  silAllowedRatios: text("sil_allowed_ratios").array().default([]).notNull(),
  
  // Community Access Category
  communityAccessTotal: decimal("community_access_total", { precision: 12, scale: 2 }).default("0").notNull(),
  communityAccessRemaining: decimal("community_access_remaining", { precision: 12, scale: 2 }).default("0").notNull(),
  communityAccessAllowedRatios: text("community_access_allowed_ratios").array().default([]).notNull(),
  
  // Capacity Building Category
  capacityBuildingTotal: decimal("capacity_building_total", { precision: 12, scale: 2 }).default("0").notNull(),
  capacityBuildingRemaining: decimal("capacity_building_remaining", { precision: 12, scale: 2 }).default("0").notNull(),
  capacityBuildingAllowedRatios: text("capacity_building_allowed_ratios").array().default([]).notNull(),
  
  // Price overrides (optional)
  priceOverrides: jsonb("price_overrides"),
  
  isActive: boolean("is_active").default(true).notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const ndisBudgetsRelations = relations(ndisBudgets, ({ one }) => ({
  client: one(clients, {
    fields: [ndisBudgets.clientId],
    references: [clients.id],
  }),
  tenant: one(tenants, {
    fields: [ndisBudgets.tenantId],
    references: [tenants.id],
  }),
}));

export const insertNdisBudgetSchema = createInsertSchema(ndisBudgets).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
  tenantId: true,
}).extend({
  clientId: z.number().positive("Client ID is required"),
  silTotal: z.number().min(0, "SIL total must be non-negative"),
  silRemaining: z.number().min(0, "SIL remaining must be non-negative"),
  silAllowedRatios: z.array(z.enum(["1:1", "1:2", "1:3", "1:4", "2:1"])),
  communityAccessTotal: z.number().min(0, "Community Access total must be non-negative"),
  communityAccessRemaining: z.number().min(0, "Community Access remaining must be non-negative"),
  communityAccessAllowedRatios: z.array(z.enum(["1:1", "1:2", "1:3", "1:4", "2:1"])),
  capacityBuildingTotal: z.number().min(0, "Capacity Building total must be non-negative"),
  capacityBuildingRemaining: z.number().min(0, "Capacity Building remaining must be non-negative"),
  capacityBuildingAllowedRatios: z.array(z.enum(["1:1", "1:2", "1:3", "1:4", "2:1"])),
  priceOverrides: z.object({
    AM: z.number().positive().optional(),
    PM: z.number().positive().optional(),
    ActiveNight: z.number().positive().optional(),
    Sleepover: z.number().positive().optional(),
  }).optional(),
});

export type NdisBudget = typeof ndisBudgets.$inferSelect;
export type InsertNdisBudget = z.infer<typeof insertNdisBudgetSchema>;

// Budget Transactions table for tracking deductions
export const budgetTransactions = pgTable("budget_transactions", {
  id: serial("id").primaryKey(),
  budgetId: integer("budget_id").notNull().references(() => ndisBudgets.id),
  shiftId: integer("shift_id").references(() => shifts.id),
  caseNoteId: integer("case_note_id").references(() => caseNotes.id),
  companyId: text("company_id").notNull().references(() => companies.id),
  
  category: text("category").notNull(), // "SIL", "CommunityAccess", "CapacityBuilding"
  shiftType: text("shift_type").notNull(), // "AM", "PM", "ActiveNight", "Sleepover"
  ratio: text("ratio").notNull(), // "1:1", "1:2", "1:3", "1:4", "2:1"
  hours: decimal("hours", { precision: 5, scale: 2 }).notNull(),
  rate: decimal("rate", { precision: 10, scale: 2 }).notNull(),
  amount: decimal("amount", { precision: 12, scale: 2 }).notNull(),
  description: text("description"),
  
  transactionType: text("transaction_type").default("deduction").notNull(), // "deduction", "adjustment", "refund"
  
  createdAt: timestamp("created_at").defaultNow().notNull(),
  createdByUserId: integer("created_by_user_id").notNull().references(() => users.id),
});

export const budgetTransactionsRelations = relations(budgetTransactions, ({ one }) => ({
  budget: one(ndisBudgets, {
    fields: [budgetTransactions.budgetId],
    references: [ndisBudgets.id],
  }),
  shift: one(shifts, {
    fields: [budgetTransactions.shiftId],
    references: [shifts.id],
  }),
  caseNote: one(caseNotes, {
    fields: [budgetTransactions.caseNoteId],
    references: [caseNotes.id],
  }),
  company: one(companies, {
    fields: [budgetTransactions.companyId],
    references: [companies.id],
  }),
  createdBy: one(users, {
    fields: [budgetTransactions.createdByUserId],
    references: [users.id],
  }),
}));

export const insertBudgetTransactionSchema = createInsertSchema(budgetTransactions).omit({
  id: true,
  createdAt: true,
  companyId: true,
  createdByUserId: true,
}).extend({
  budgetId: z.number().positive("Budget ID is required"),
  category: z.enum(["SIL", "CommunityAccess", "CapacityBuilding"]),
  shiftType: z.enum(["AM", "PM", "ActiveNight", "Sleepover"]),
  ratio: z.enum(["1:1", "1:2", "1:3", "1:4"]),
  hours: z.number().positive("Hours must be positive"),
  rate: z.number().positive("Rate must be positive"),
  amount: z.number().positive("Amount must be positive"),
  transactionType: z.enum(["deduction", "adjustment", "refund"]),
});

export type BudgetTransaction = typeof budgetTransactions.$inferSelect;
export type InsertBudgetTransaction = z.infer<typeof insertBudgetTransactionSchema>;

// Care Support Plans
export const careSupportPlans = pgTable("care_support_plans", {
  id: serial("id").primaryKey(),
  clientId: integer("client_id").references(() => clients.id).notNull(),
  tenantId: integer("tenant_id").references(() => tenants.id).notNull(),
  planTitle: text("plan_title").notNull(),
  status: text("status").default("draft"), // draft, completed, active
  
  // Section Data (JSONB for flexibility)
  aboutMeData: jsonb("about_me_data"), // { bulletPoints: string[], generatedText: string, aiAttempts: number }
  goalsData: jsonb("goals_data"), // { ndisGoals: string, generalGoals: string, generatedGoals: string, aiAttempts: number }
  adlData: jsonb("adl_data"), // { userInput: string, generatedContent: string, aiAttempts: number }
  structureData: jsonb("structure_data"), // { routines: [{ day, startTime, finishTime, activity, notes }] }
  communicationData: jsonb("communication_data"), // { expressive: string, receptive: string, generatedStrategy: string, aiAttempts: number }
  behaviourData: jsonb("behaviour_data"), // { behaviours: [{ behaviour, trigger, proactive, reactive, protective, aiAttempts }] }
  disasterData: jsonb("disaster_data"), // { scenarios: { [type]: { preparation, evacuation, postEvent, aiAttempts } } }
  mealtimeData: jsonb("mealtime_data"), // { riskParameters: [], generatedPlan: string, aiAttempts: number }
  
  createdByUserId: integer("created_by_user_id").references(() => users.id).notNull(),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

export const careSupportPlansRelations = relations(careSupportPlans, ({ one }) => ({
  client: one(clients, {
    fields: [careSupportPlans.clientId],
    references: [clients.id],
  }),
  tenant: one(tenants, {
    fields: [careSupportPlans.tenantId],
    references: [tenants.id],
  }),
  createdBy: one(users, {
    fields: [careSupportPlans.createdByUserId],
    references: [users.id],
  }),
}));

export const insertCareSupportPlanSchema = createInsertSchema(careSupportPlans).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
}).extend({
  planTitle: z.string().min(1, "Plan title is required").max(255, "Plan title cannot exceed 255 characters"),
  status: z.enum(["draft", "completed", "active"]).default("draft"),
  clientId: z.number().positive("Client ID is required"),
  tenantId: z.number().positive("Tenant ID is required"),
  createdByUserId: z.number().positive("Created by user ID is required"),
});

export type InsertCareSupportPlan = z.infer<typeof insertCareSupportPlanSchema>;
export type CareSupportPlan = typeof careSupportPlans.$inferSelect;

// Pay Scale Management
export const payScales = pgTable("pay_scales", {
  id: serial("id").primaryKey(),
  tenantId: integer("tenant_id").references(() => tenants.id).notNull(),
  level: integer("level").notNull(), // 1-4
  payPoint: integer("pay_point").notNull(), // 1-4
  employmentType: text("employment_type").notNull().default("fulltime"), // "fulltime", "parttime", "casual"
  hourlyRate: decimal("hourly_rate", { precision: 8, scale: 2 }).notNull(),
  effectiveDate: timestamp("effective_date").defaultNow().notNull(),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Timesheets
export const timesheets = pgTable("timesheets", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  tenantId: integer("tenant_id").references(() => tenants.id).notNull(),
  payPeriodStart: timestamp("pay_period_start").notNull(),
  payPeriodEnd: timestamp("pay_period_end").notNull(),
  status: text("status").default("draft"), // draft, submitted, approved, rejected, paid
  totalHours: decimal("total_hours", { precision: 8, scale: 2 }).default("0"),
  totalEarnings: decimal("total_earnings", { precision: 10, scale: 2 }).default("0"),
  totalTax: decimal("total_tax", { precision: 10, scale: 2 }).default("0"),
  totalSuper: decimal("total_super", { precision: 10, scale: 2 }).default("0"),
  netPay: decimal("net_pay", { precision: 10, scale: 2 }).default("0"),
  submittedAt: timestamp("submitted_at"),
  approvedAt: timestamp("approved_at"),
  approvedBy: integer("approved_by").references(() => users.id),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Timesheet Entries (individual shift entries)
export const timesheetEntries = pgTable("timesheet_entries", {
  id: serial("id").primaryKey(),
  timesheetId: integer("timesheet_id").references(() => timesheets.id).notNull(),
  shiftId: integer("shift_id").references(() => shifts.id),
  entryDate: timestamp("entry_date").notNull(),
  startTime: timestamp("start_time").notNull(),
  endTime: timestamp("end_time").notNull(),
  breakMinutes: integer("break_minutes").default(0),
  totalHours: decimal("total_hours", { precision: 8, scale: 2 }).notNull(),
  hourlyRate: decimal("hourly_rate", { precision: 8, scale: 2 }).notNull(),
  grossPay: decimal("gross_pay", { precision: 10, scale: 2 }).notNull(),
  isAutoGenerated: boolean("is_auto_generated").default(true),
  notes: text("notes"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Australian Tax Brackets (updated annually)
export const taxBrackets = pgTable("tax_brackets", {
  id: serial("id").primaryKey(),
  taxYear: text("tax_year").notNull(), // e.g., "2024-25"
  minIncome: decimal("min_income", { precision: 10, scale: 2 }).notNull(),
  maxIncome: decimal("max_income", { precision: 10, scale: 2 }),
  taxRate: decimal("tax_rate", { precision: 5, scale: 4 }).notNull(), // as decimal (e.g., 0.19 for 19%)
  baseTax: decimal("base_tax", { precision: 10, scale: 2 }).default("0"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
});

// Leave Balances
export const leaveBalances = pgTable("leave_balances", {
  id: serial("id").primaryKey(),
  userId: integer("user_id").references(() => users.id).notNull(),
  tenantId: integer("tenant_id").references(() => tenants.id).notNull(),
  annualLeave: decimal("annual_leave", { precision: 8, scale: 2 }).default("0"),
  sickLeave: decimal("sick_leave", { precision: 8, scale: 2 }).default("0"),
  longServiceLeave: decimal("long_service_leave", { precision: 8, scale: 2 }).default("0"),
  personalLeave: decimal("personal_leave", { precision: 8, scale: 2 }).default("0"),
  accrualRate: decimal("accrual_rate", { precision: 8, scale: 4 }).default("0.0769"), // 4 weeks per year
  lastUpdated: timestamp("last_updated").defaultNow().notNull(),
});

// Payslips
export const payslips = pgTable("payslips", {
  id: serial("id").primaryKey(),
  timesheetId: integer("timesheet_id").references(() => timesheets.id).notNull(),
  userId: integer("user_id").references(() => users.id).notNull(),
  tenantId: integer("tenant_id").references(() => tenants.id).notNull(),
  payPeriodStart: timestamp("pay_period_start").notNull(),
  payPeriodEnd: timestamp("pay_period_end").notNull(),
  grossPay: decimal("gross_pay", { precision: 10, scale: 2 }).notNull(),
  taxWithheld: decimal("tax_withheld", { precision: 10, scale: 2 }).notNull(),
  superContribution: decimal("super_contribution", { precision: 10, scale: 2 }).notNull(),
  netPay: decimal("net_pay", { precision: 10, scale: 2 }).notNull(),
  ytdGross: decimal("ytd_gross", { precision: 10, scale: 2 }).default("0"),
  ytdTax: decimal("ytd_tax", { precision: 10, scale: 2 }).default("0"),
  ytdSuper: decimal("ytd_super", { precision: 10, scale: 2 }).default("0"),
  pdfPath: text("pdf_path"),
  generatedAt: timestamp("generated_at").defaultNow().notNull(),
});

// Relations
export const payScalesRelations = relations(payScales, ({ one }) => ({
  tenant: one(tenants, {
    fields: [payScales.tenantId],
    references: [tenants.id],
  }),
}));

export const timesheetsRelations = relations(timesheets, ({ one, many }) => ({
  user: one(users, {
    fields: [timesheets.userId],
    references: [users.id],
  }),
  tenant: one(tenants, {
    fields: [timesheets.tenantId],
    references: [tenants.id],
  }),
  approver: one(users, {
    fields: [timesheets.approvedBy],
    references: [users.id],
  }),
  entries: many(timesheetEntries),
  payslip: one(payslips),
}));

export const timesheetEntriesRelations = relations(timesheetEntries, ({ one }) => ({
  timesheet: one(timesheets, {
    fields: [timesheetEntries.timesheetId],
    references: [timesheets.id],
  }),
  shift: one(shifts, {
    fields: [timesheetEntries.shiftId],
    references: [shifts.id],
  }),
}));

export const leaveBalancesRelations = relations(leaveBalances, ({ one }) => ({
  user: one(users, {
    fields: [leaveBalances.userId],
    references: [users.id],
  }),
  tenant: one(tenants, {
    fields: [leaveBalances.tenantId],
    references: [tenants.id],
  }),
}));

export const payslipsRelations = relations(payslips, ({ one }) => ({
  timesheet: one(timesheets, {
    fields: [payslips.timesheetId],
    references: [timesheets.id],
  }),
  user: one(users, {
    fields: [payslips.userId],
    references: [users.id],
  }),
  tenant: one(tenants, {
    fields: [payslips.tenantId],
    references: [tenants.id],
  }),
}));

// Insert schemas
export const insertPayScaleSchema = createInsertSchema(payScales).omit({
  id: true,
  createdAt: true,
});

export const insertTimesheetSchema = createInsertSchema(timesheets).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

export const insertTimesheetEntrySchema = createInsertSchema(timesheetEntries).omit({
  id: true,
  createdAt: true,
});

export const insertLeaveBalanceSchema = createInsertSchema(leaveBalances).omit({
  id: true,
  lastUpdated: true,
});

export const insertPayslipSchema = createInsertSchema(payslips).omit({
  id: true,
  generatedAt: true,
});

// Types
export type PayScale = typeof payScales.$inferSelect;
export type InsertPayScale = z.infer<typeof insertPayScaleSchema>;
export type Timesheet = typeof timesheets.$inferSelect;
export type InsertTimesheet = z.infer<typeof insertTimesheetSchema>;
export type TimesheetEntry = typeof timesheetEntries.$inferSelect;
export type InsertTimesheetEntry = z.infer<typeof insertTimesheetEntrySchema>;
export type TaxBracket = typeof taxBrackets.$inferSelect;
export type LeaveBalance = typeof leaveBalances.$inferSelect;
export type InsertLeaveBalance = z.infer<typeof insertLeaveBalanceSchema>;
export type Payslip = typeof payslips.$inferSelect;
export type InsertPayslip = z.infer<typeof insertPayslipSchema>;

// Shift Cancellation Types
export type ShiftCancellation = typeof shiftCancellations.$inferSelect;
export type InsertShiftCancellation = z.infer<typeof insertShiftCancellationSchema>;
export type CancellationRequest = typeof cancellationRequests.$inferSelect;
export type InsertCancellationRequest = z.infer<typeof insertCancellationRequestSchema>;
