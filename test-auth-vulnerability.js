#!/usr/bin/env node

/**
 * ğŸ”’ CRITICAL SECURITY TEST: Authentication Vulnerability Reproduction
 * 
 * This script reproduces the authentication bypass issue where SupportWorkers
 * gain unauthorized access to client data on subsequent logins.
 */

import https from 'https';
import http from 'http';

const API_BASE = 'http://localhost:5000';

// Test credentials for SupportWorker
const TEST_CREDENTIALS = {
  username: 'hh',  // Using existing user
  password: 'test'  // Assuming test password
};

/**
 * Make HTTP request with cookie support
 */
function makeRequest(method, path, data = null, cookies = '') {
  return new Promise((resolve, reject) => {
    const options = {
      hostname: 'localhost',
      port: 5000,
      path: path,
      method: method,
      headers: {
        'Content-Type': 'application/json',
        'Cookie': cookies
      }
    };

    const req = http.request(options, (res) => {
      let body = '';
      res.on('data', (chunk) => body += chunk);
      res.on('end', () => {
        const setCookieHeader = res.headers['set-cookie'];
        resolve({
          status: res.statusCode,
          headers: res.headers,
          body: body,
          cookies: setCookieHeader ? setCookieHeader.join('; ') : ''
        });
      });
    });

    req.on('error', reject);
    
    if (data) {
      req.write(JSON.stringify(data));
    }
    
    req.end();
  });
}

/**
 * Test the authentication vulnerability
 */
async function testAuthVulnerability() {
  console.log('ğŸ”’ [SECURITY TEST] Starting authentication vulnerability test...\n');

  try {
    // Step 1: First login
    console.log('1ï¸âƒ£ [FIRST LOGIN] Logging in as SupportWorker...');
    const loginResponse1 = await makeRequest('POST', '/api/login', TEST_CREDENTIALS);
    
    if (loginResponse1.status !== 200) {
      console.log('âŒ Login failed:', loginResponse1.status, loginResponse1.body);
      return;
    }
    
    const sessionCookies1 = loginResponse1.cookies;
    console.log('âœ… First login successful');
    console.log('ğŸª Session cookies:', sessionCookies1.substring(0, 50) + '...');

    // Step 2: First client data fetch (should be empty for SupportWorker with no shifts)
    console.log('\n2ï¸âƒ£ [FIRST CLIENT FETCH] Fetching client data after first login...');
    const clientsResponse1 = await makeRequest('GET', '/api/clients', null, sessionCookies1);
    
    console.log('ğŸ“Š First fetch status:', clientsResponse1.status);
    console.log('ğŸ“Š First fetch response:', clientsResponse1.body);
    
    const firstFetchClients = JSON.parse(clientsResponse1.body || '[]');
    console.log(`ğŸ” First fetch result: ${firstFetchClients.length} clients`);

    // Step 3: Logout
    console.log('\n3ï¸âƒ£ [LOGOUT] Logging out...');
    const logoutResponse = await makeRequest('POST', '/api/logout', null, sessionCookies1);
    console.log('âœ… Logout status:', logoutResponse.status);

    // Step 4: Second login (same user)
    console.log('\n4ï¸âƒ£ [SECOND LOGIN] Logging in again as same SupportWorker...');
    const loginResponse2 = await makeRequest('POST', '/api/login', TEST_CREDENTIALS);
    
    if (loginResponse2.status !== 200) {
      console.log('âŒ Second login failed:', loginResponse2.status, loginResponse2.body);
      return;
    }
    
    const sessionCookies2 = loginResponse2.cookies;
    console.log('âœ… Second login successful');
    console.log('ğŸª New session cookies:', sessionCookies2.substring(0, 50) + '...');

    // Step 5: Second client data fetch (CRITICAL: should still be empty)
    console.log('\n5ï¸âƒ£ [SECOND CLIENT FETCH] Fetching client data after second login...');
    const clientsResponse2 = await makeRequest('GET', '/api/clients', null, sessionCookies2);
    
    console.log('ğŸ“Š Second fetch status:', clientsResponse2.status);
    console.log('ğŸ“Š Second fetch response:', clientsResponse2.body);
    
    const secondFetchClients = JSON.parse(clientsResponse2.body || '[]');
    console.log(`ğŸ” Second fetch result: ${secondFetchClients.length} clients`);

    // Step 6: Vulnerability analysis
    console.log('\nğŸš¨ [VULNERABILITY ANALYSIS]');
    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
    
    if (firstFetchClients.length === 0 && secondFetchClients.length === 0) {
      console.log('âœ… SECURITY OK: Both fetches returned 0 clients (correct behavior)');
    } else if (firstFetchClients.length === 0 && secondFetchClients.length > 0) {
      console.log('ğŸš¨ CRITICAL VULNERABILITY DETECTED:');
      console.log(`   First login: ${firstFetchClients.length} clients (correct)`);
      console.log(`   Second login: ${secondFetchClients.length} clients (UNAUTHORIZED ACCESS)`);
      console.log('   SupportWorker gained unauthorized access on re-login!');
    } else if (firstFetchClients.length > 0) {
      console.log('âš ï¸  UNEXPECTED: First login already returned clients');
      console.log('   This might indicate existing shift assignments or other security issues');
    }

    console.log('\nğŸ“‹ [TEST SUMMARY]');
    console.log(`â€¢ User: ${TEST_CREDENTIALS.username}`);
    console.log(`â€¢ First login clients: ${firstFetchClients.length}`);
    console.log(`â€¢ Second login clients: ${secondFetchClients.length}`);
    console.log(`â€¢ Vulnerability present: ${firstFetchClients.length === 0 && secondFetchClients.length > 0 ? 'YES' : 'NO'}`);

  } catch (error) {
    console.error('âŒ Test failed with error:', error.message);
  }
}

// Run the test
testAuthVulnerability();