import { db } from "./db";
import { timesheets, timesheetEntries, shifts, users, payScales } from "@shared/schema";
import { eq, and, gte, lte, desc } from "drizzle-orm";
import { calculatePayroll, calculatePayPeriod, updateLeaveBalances } from "./payroll-calculator";

export interface TimesheetSummary {
  timesheet: any;
  entries: any[];
  totalHours: number;
  totalEarnings: number;
  periodStatus: 'current' | 'previous' | 'future';
}

export async function getCurrentTimesheet(userId: number, tenantId: number): Promise<TimesheetSummary | null> {
  const now = new Date();
  const payPeriod = calculatePayPeriod(now);

  const timesheet = await db
    .select()
    .from(timesheets)
    .where(and(
      eq(timesheets.userId, userId),
      eq(timesheets.tenantId, tenantId),
      eq(timesheets.payPeriodStart, payPeriod.start),
      eq(timesheets.payPeriodEnd, payPeriod.end)
    ))
    .limit(1);

  if (!timesheet.length) {
    return null;
  }

  const entries = await db
    .select({
      id: timesheetEntries.id,
      entryDate: timesheetEntries.entryDate,
      startTime: timesheetEntries.startTime,
      endTime: timesheetEntries.endTime,
      totalHours: timesheetEntries.totalHours,
      grossPay: timesheetEntries.grossPay,
      notes: timesheetEntries.notes,
      shiftTitle: shifts.title
    })
    .from(timesheetEntries)
    .leftJoin(shifts, eq(timesheetEntries.shiftId, shifts.id))
    .where(eq(timesheetEntries.timesheetId, timesheet[0].id))
    .orderBy(desc(timesheetEntries.entryDate));

  const totalHours = parseFloat(timesheet[0].totalHours || '0');
  const totalEarnings = parseFloat(timesheet[0].totalEarnings || '0');

  return {
    timesheet: timesheet[0],
    entries,
    totalHours,
    totalEarnings,
    periodStatus: 'current'
  };
}

export async function getTimesheetHistory(userId: number, tenantId: number): Promise<any[]> {
  const timesheetHistory = await db
    .select()
    .from(timesheets)
    .where(and(
      eq(timesheets.userId, userId),
      eq(timesheets.tenantId, tenantId)
    ))
    .orderBy(desc(timesheets.payPeriodStart));

  return timesheetHistory;
}

export async function createTimesheetEntryFromShift(shiftId: number): Promise<void> {
  // Get the completed shift details
  const shift = await db
    .select()
    .from(shifts)
    .where(eq(shifts.id, shiftId))
    .limit(1);

  if (!shift.length || !shift[0].startTime || !shift[0].endTime) {
    throw new Error("Shift not completed or missing start/end times");
  }

  const shiftData = shift[0];
  const userId = shiftData.userId;
  const tenantId = shiftData.tenantId;

  if (!userId) {
    throw new Error("Shift has no assigned user");
  }

  // Calculate hours worked
  const startTime = new Date(shiftData.startTime);
  const endTime = new Date(shiftData.endTime);
  const totalMinutes = (endTime.getTime() - startTime.getTime()) / (1000 * 60);
  const breakMinutes = 30; // Standard break time
  const workedMinutes = totalMinutes - breakMinutes;
  const totalHours = Math.round((workedMinutes / 60) * 100) / 100;

  // Get hourly rate for the user
  const hourlyRate = await getUserHourlyRate(userId, tenantId);
  const grossPay = totalHours * hourlyRate;

  // Find or create timesheet for the pay period
  const payPeriod = calculatePayPeriod(startTime);
  let timesheet = await findOrCreateTimesheet(userId, tenantId, payPeriod);

  // Check if entry already exists for this shift
  const existingEntry = await db
    .select()
    .from(timesheetEntries)
    .where(and(
      eq(timesheetEntries.timesheetId, timesheet.id),
      eq(timesheetEntries.shiftId, shiftId)
    ))
    .limit(1);

  if (existingEntry.length) {
    // Update existing entry
    await db
      .update(timesheetEntries)
      .set({
        startTime,
        endTime,
        breakMinutes,
        totalHours: String(totalHours),
        hourlyRate: String(hourlyRate),
        grossPay: String(grossPay)
      })
      .where(eq(timesheetEntries.id, existingEntry[0].id));
  } else {
    // Create new timesheet entry
    await db.insert(timesheetEntries).values({
      timesheetId: timesheet.id,
      shiftId,
      entryDate: startTime,
      startTime,
      endTime,
      breakMinutes,
      totalHours: String(totalHours),
      hourlyRate: String(hourlyRate),
      grossPay: String(grossPay),
      isAutoGenerated: true,
      notes: `Auto-generated from shift: ${shiftData.title}`
    });
  }

  // Update timesheet totals
  await updateTimesheetTotals(timesheet.id);
}

async function findOrCreateTimesheet(userId: number, tenantId: number, payPeriod: { start: Date; end: Date }) {
  // Try to find existing timesheet
  let timesheet = await db
    .select()
    .from(timesheets)
    .where(and(
      eq(timesheets.userId, userId),
      eq(timesheets.tenantId, tenantId),
      eq(timesheets.payPeriodStart, payPeriod.start),
      eq(timesheets.payPeriodEnd, payPeriod.end)
    ))
    .limit(1);

  if (timesheet.length) {
    return timesheet[0];
  }

  // Create new timesheet
  const newTimesheet = await db.insert(timesheets).values({
    userId,
    tenantId,
    payPeriodStart: payPeriod.start,
    payPeriodEnd: payPeriod.end,
    status: 'draft',
    totalHours: '0',
    totalEarnings: '0',
    totalTax: '0',
    totalSuper: '0',
    netPay: '0'
  }).returning();

  return newTimesheet[0];
}

async function updateTimesheetTotals(timesheetId: number): Promise<void> {
  // Get all entries for this timesheet
  const entries = await db
    .select()
    .from(timesheetEntries)
    .where(eq(timesheetEntries.timesheetId, timesheetId));

  const totalHours = entries.reduce((sum, entry) => sum + parseFloat(entry.totalHours || '0'), 0);
  const totalGrossPay = entries.reduce((sum, entry) => sum + parseFloat(entry.grossPay || '0'), 0);

  // Get timesheet to get user and tenant info
  const timesheet = await db
    .select()
    .from(timesheets)
    .where(eq(timesheets.id, timesheetId))
    .limit(1);

  if (!timesheet.length) return;

  // Calculate payroll with tax and super
  const payrollCalculation = await calculatePayroll(
    timesheet[0].userId,
    timesheet[0].tenantId,
    totalHours,
    totalGrossPay
  );

  // Update timesheet totals
  await db
    .update(timesheets)
    .set({
      totalHours: String(totalHours),
      totalEarnings: String(totalGrossPay),
      totalTax: String(payrollCalculation.taxWithheld),
      totalSuper: String(payrollCalculation.superContribution),
      netPay: String(payrollCalculation.netPay),
      updatedAt: new Date()
    })
    .where(eq(timesheets.id, timesheetId));
}

async function getUserHourlyRate(userId: number, tenantId: number): Promise<number> {
  // Get user's pay scale level and point
  const user = await db
    .select({
      payScaleLevel: users.payScaleLevel,
      payScalePoint: users.payScalePoint,
      employmentType: users.employmentType
    })
    .from(users)
    .where(eq(users.id, userId))
    .limit(1);

  if (!user.length || !user[0].payScaleLevel || !user[0].payScalePoint) {
    // Return minimum wage if no pay scale configured
    return 23.23;
  }

  // Get pay scale rate
  const payScale = await db
    .select()
    .from(payScales)
    .where(and(
      eq(payScales.tenantId, tenantId),
      eq(payScales.level, user[0].payScaleLevel),
      eq(payScales.payPoint, user[0].payScalePoint),
      eq(payScales.employmentType, user[0].employmentType || 'fulltime')
    ))
    .limit(1);

  if (!payScale.length) {
    // Return minimum wage if no pay scale configured
    return 23.23;
  }

  return parseFloat(payScale[0].hourlyRate);
}

export async function submitTimesheet(timesheetId: number, userId: number): Promise<boolean> {
  // Verify timesheet belongs to user
  const timesheet = await db
    .select()
    .from(timesheets)
    .where(and(eq(timesheets.id, timesheetId), eq(timesheets.userId, userId)))
    .limit(1);

  if (!timesheet.length) {
    throw new Error("Timesheet not found or access denied");
  }

  // Check if timesheet has entries
  const entries = await db
    .select()
    .from(timesheetEntries)
    .where(eq(timesheetEntries.timesheetId, timesheetId));

  if (!entries.length) {
    throw new Error("Cannot submit empty timesheet");
  }

  // Auto-approve if all entries are auto-generated from shifts
  const allAutoGenerated = entries.every(entry => entry.isAutoGenerated);
  const newStatus = allAutoGenerated ? 'approved' : 'submitted';
  const approvedAt = allAutoGenerated ? new Date() : null;

  await db
    .update(timesheets)
    .set({
      status: newStatus,
      submittedAt: new Date(),
      approvedAt,
      updatedAt: new Date()
    })
    .where(eq(timesheets.id, timesheetId));

  return allAutoGenerated; // Returns true if auto-approved
}

export async function canAddManualEntry(userId: number, tenantId: number, entryDate: Date): Promise<boolean> {
  // Check if there's a corresponding shift for this date
  const dayStart = new Date(entryDate);
  dayStart.setHours(0, 0, 0, 0);
  const dayEnd = new Date(entryDate);
  dayEnd.setHours(23, 59, 59, 999);

  const correspondingShift = await db
    .select()
    .from(shifts)
    .where(and(
      eq(shifts.userId, userId),
      eq(shifts.tenantId, tenantId),
      gte(shifts.startTime, dayStart),
      lte(shifts.startTime, dayEnd)
    ))
    .limit(1);

  return correspondingShift.length > 0;
}