import { db } from "./db";
import { timesheets, timesheetEntries, shifts, users, payScales } from "@shared/schema";
import { eq, and, gte, lte, desc } from "drizzle-orm";
import { calculatePayroll, calculatePayPeriod, updateLeaveBalances } from "./payroll-calculator";

export interface TimesheetSummary {
  timesheet: any;
  entries: any[];
  totalHours: number;
  totalEarnings: number;
  periodStatus: 'current' | 'previous' | 'future';
}

export async function createTimesheetEntryFromShift(shiftId: number): Promise<void> {
  // Get the completed shift details
  const shift = await db
    .select()
    .from(shifts)
    .where(eq(shifts.id, shiftId))
    .limit(1);

  if (!shift.length || !shift[0].actualStartTime || !shift[0].actualEndTime) {
    throw new Error("Shift not completed or missing actual times");
  }

  const shiftData = shift[0];
  const userId = shiftData.userId;
  const tenantId = shiftData.tenantId;

  if (!userId) {
    throw new Error("Shift has no assigned user");
  }

  // Calculate hours worked
  const startTime = new Date(shiftData.actualStartTime);
  const endTime = new Date(shiftData.actualEndTime);
  const totalMinutes = (endTime.getTime() - startTime.getTime()) / (1000 * 60);
  const breakMinutes = 30; // Standard break time
  const workedMinutes = totalMinutes - breakMinutes;
  const totalHours = Math.round((workedMinutes / 60) * 100) / 100;

  // Get hourly rate for the user
  const hourlyRate = await getUserHourlyRate(userId, tenantId);
  const grossPay = totalHours * hourlyRate;

  // Find or create timesheet for the pay period
  const payPeriod = calculatePayPeriod(startTime);
  let timesheet = await findOrCreateTimesheet(userId, tenantId, payPeriod);

  // Check if entry already exists for this shift
  const existingEntry = await db
    .select()
    .from(timesheetEntries)
    .where(and(
      eq(timesheetEntries.timesheetId, timesheet.id),
      eq(timesheetEntries.shiftId, shiftId)
    ))
    .limit(1);

  if (existingEntry.length) {
    // Update existing entry
    await db
      .update(timesheetEntries)
      .set({
        startTime,
        endTime,
        breakMinutes,
        totalHours: String(totalHours),
        hourlyRate: String(hourlyRate),
        grossPay: String(grossPay)
      })
      .where(eq(timesheetEntries.id, existingEntry[0].id));
  } else {
    // Create new timesheet entry
    await db.insert(timesheetEntries).values({
      timesheetId: timesheet.id,
      shiftId,
      entryDate: startTime,
      startTime,
      endTime,
      breakMinutes,
      totalHours: String(totalHours),
      hourlyRate: String(hourlyRate),
      grossPay: String(grossPay),
      isAutoGenerated: true,
      notes: `Auto-generated from shift: ${shiftData.title}`
    });
  }

  // Update timesheet totals
  await updateTimesheetTotals(timesheet.id);
}

async function findOrCreateTimesheet(userId: number, tenantId: number, payPeriod: { start: Date; end: Date }) {
  // Look for existing timesheet in this pay period
  const existing = await db
    .select()
    .from(timesheets)
    .where(and(
      eq(timesheets.userId, userId),
      eq(timesheets.tenantId, tenantId),
      eq(timesheets.payPeriodStart, payPeriod.start),
      eq(timesheets.payPeriodEnd, payPeriod.end)
    ))
    .limit(1);

  if (existing.length) {
    return existing[0];
  }

  // Create new timesheet
  const newTimesheet = await db.insert(timesheets).values({
    userId,
    tenantId,
    payPeriodStart: payPeriod.start,
    payPeriodEnd: payPeriod.end,
    status: 'draft'
  }).returning();

  return newTimesheet[0];
}

async function updateTimesheetTotals(timesheetId: number): Promise<void> {
  // Get all entries for this timesheet
  const entries = await db
    .select()
    .from(timesheetEntries)
    .where(eq(timesheetEntries.timesheetId, timesheetId));

  const totalHours = entries.reduce((sum, entry) => sum + parseFloat(entry.totalHours), 0);
  const totalEarnings = entries.reduce((sum, entry) => sum + parseFloat(entry.grossPay), 0);

  // Get timesheet details for payroll calculation
  const timesheet = await db
    .select()
    .from(timesheets)
    .where(eq(timesheets.id, timesheetId))
    .limit(1);

  if (!timesheet.length) return;

  // Calculate payroll including tax and super
  const payrollCalc = await calculatePayroll(
    timesheet[0].userId,
    timesheet[0].tenantId,
    totalEarnings
  );

  // Update timesheet with calculated totals
  await db
    .update(timesheets)
    .set({
      totalHours: String(totalHours),
      totalEarnings: String(totalEarnings),
      totalTax: String(payrollCalc.taxWithheld),
      totalSuper: String(payrollCalc.superContribution),
      netPay: String(payrollCalc.netPay),
      updatedAt: new Date()
    })
    .where(eq(timesheets.id, timesheetId));

  // Update leave balances
  await updateLeaveBalances(
    timesheet[0].userId,
    timesheet[0].tenantId,
    payrollCalc.leaveAccrued
  );
}

async function getUserHourlyRate(userId: number, tenantId: number): Promise<number> {
  const user = await db
    .select()
    .from(users)
    .where(and(eq(users.id, userId), eq(users.tenantId, tenantId)))
    .limit(1);

  if (!user.length) {
    throw new Error("User not found");
  }

  const { payLevel = 1, payPoint = 1 } = user[0];

  const payScale = await db
    .select()
    .from(payScales)
    .where(and(
      eq(payScales.tenantId, tenantId),
      eq(payScales.level, payLevel),
      eq(payScales.payPoint, payPoint)
    ))
    .limit(1);

  if (!payScale.length) {
    // Return minimum wage if no pay scale configured
    return 23.23;
  }

  return parseFloat(payScale[0].hourlyRate);
}

export async function getCurrentTimesheet(userId: number, tenantId: number): Promise<TimesheetSummary | null> {
  const now = new Date();
  const payPeriod = calculatePayPeriod(now);

  const timesheet = await db
    .select()
    .from(timesheets)
    .where(and(
      eq(timesheets.userId, userId),
      eq(timesheets.tenantId, tenantId),
      eq(timesheets.payPeriodStart, payPeriod.start),
      eq(timesheets.payPeriodEnd, payPeriod.end)
    ))
    .limit(1);

  if (!timesheet.length) {
    return null;
  }

  const entries = await db
    .select({
      id: timesheetEntries.id,
      entryDate: timesheetEntries.entryDate,
      startTime: timesheetEntries.startTime,
      endTime: timesheetEntries.endTime,
      totalHours: timesheetEntries.totalHours,
      grossPay: timesheetEntries.grossPay,
      notes: timesheetEntries.notes,
      shiftTitle: shifts.title
    })
    .from(timesheetEntries)
    .leftJoin(shifts, eq(timesheetEntries.shiftId, shifts.id))
    .where(eq(timesheetEntries.timesheetId, timesheet[0].id))
    .orderBy(desc(timesheetEntries.entryDate));

  const totalHours = parseFloat(timesheet[0].totalHours);
  const totalEarnings = parseFloat(timesheet[0].totalEarnings);

  return {
    timesheet: timesheet[0],
    entries,
    totalHours,
    totalEarnings,
    periodStatus: 'current'
  };
}

export async function submitTimesheet(timesheetId: number, userId: number): Promise<boolean> {
  // Verify timesheet belongs to user
  const timesheet = await db
    .select()
    .from(timesheets)
    .where(and(eq(timesheets.id, timesheetId), eq(timesheets.userId, userId)))
    .limit(1);

  if (!timesheet.length) {
    throw new Error("Timesheet not found or access denied");
  }

  // Check if timesheet has entries
  const entries = await db
    .select()
    .from(timesheetEntries)
    .where(eq(timesheetEntries.timesheetId, timesheetId));

  if (!entries.length) {
    throw new Error("Cannot submit empty timesheet");
  }

  // Auto-approve if all entries are auto-generated from shifts
  const allAutoGenerated = entries.every(entry => entry.isAutoGenerated);
  const newStatus = allAutoGenerated ? 'approved' : 'submitted';
  const approvedAt = allAutoGenerated ? new Date() : null;

  await db
    .update(timesheets)
    .set({
      status: newStatus,
      submittedAt: new Date(),
      approvedAt,
      updatedAt: new Date()
    })
    .where(eq(timesheets.id, timesheetId));

  return allAutoGenerated; // Returns true if auto-approved
}

export async function getTimesheetHistory(userId: number, tenantId: number, limit: number = 10) {
  return await db
    .select()
    .from(timesheets)
    .where(and(eq(timesheets.userId, userId), eq(timesheets.tenantId, tenantId)))
    .orderBy(desc(timesheets.payPeriodEnd))
    .limit(limit);
}

export async function canAddManualEntry(userId: number, tenantId: number, entryDate: Date): Promise<boolean> {
  // Check if there's a corresponding shift for this date
  const dayStart = new Date(entryDate);
  dayStart.setHours(0, 0, 0, 0);
  const dayEnd = new Date(entryDate);
  dayEnd.setHours(23, 59, 59, 999);

  const correspondingShift = await db
    .select()
    .from(shifts)
    .where(and(
      eq(shifts.userId, userId),
      eq(shifts.tenantId, tenantId),
      gte(shifts.startTime, dayStart),
      lte(shifts.startTime, dayEnd)
    ))
    .limit(1);

  return correspondingShift.length > 0;
}