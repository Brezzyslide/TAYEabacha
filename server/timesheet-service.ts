import { db } from "./db";
import { timesheets, timesheetEntries, shifts, users, payScales, clients } from "@shared/schema";
import { eq, and, gte, lte, desc } from "drizzle-orm";
import { calculatePayroll, calculatePayPeriod, updateLeaveBalances } from "./payroll-calculator";

export interface TimesheetSummary {
  timesheet: any;
  entries: any[];
  totalHours: number;
  totalEarnings: number;
  periodStatus: 'current' | 'previous' | 'future';
}

export async function getCurrentTimesheet(userId: number, tenantId: number): Promise<TimesheetSummary | null> {
  const now = new Date();
  const payPeriod = calculatePayPeriod(now);

  console.log(`[TIMESHEET SERVICE] Getting current timesheet for user ${userId}, tenant ${tenantId}`);
  console.log(`[TIMESHEET SERVICE] Pay period: ${payPeriod.start.toISOString()} to ${payPeriod.end.toISOString()}`);

  // First try to get timesheet for the exact current pay period
  let timesheet = await db
    .select()
    .from(timesheets)
    .where(and(
      eq(timesheets.userId, userId),
      eq(timesheets.tenantId, tenantId),
      gte(timesheets.payPeriodEnd, payPeriod.start),
      lte(timesheets.payPeriodStart, payPeriod.end)
    ))
    .orderBy(desc(timesheets.payPeriodStart))
    .limit(1);

  // If no timesheet found for current period, get the most recent one
  if (!timesheet.length) {
    timesheet = await db
      .select()
      .from(timesheets)
      .where(and(
        eq(timesheets.userId, userId),
        eq(timesheets.tenantId, tenantId)
      ))
      .orderBy(desc(timesheets.payPeriodStart))
      .limit(1);
  }

  console.log(`[TIMESHEET SERVICE] Found ${timesheet.length} timesheets for user ${userId}`);
  
  if (!timesheet.length) {
    console.log(`[TIMESHEET SERVICE] No timesheet found for user ${userId}, tenant ${tenantId}`);
    return null;
  }

  console.log(`[TIMESHEET SERVICE] Using timesheet ID ${timesheet[0].id}, status: ${timesheet[0].status}`);

  const entries = await db
    .select({
      id: timesheetEntries.id,
      shiftId: timesheetEntries.shiftId,
      entryDate: timesheetEntries.entryDate,
      startTime: timesheetEntries.startTime,
      endTime: timesheetEntries.endTime,
      breakMinutes: timesheetEntries.breakMinutes,
      totalHours: timesheetEntries.totalHours,
      hourlyRate: timesheetEntries.hourlyRate,
      grossPay: timesheetEntries.grossPay,
      isAutoGenerated: timesheetEntries.isAutoGenerated,
      notes: timesheetEntries.notes,
      createdAt: timesheetEntries.createdAt,
      shiftTitle: shifts.title,
      clientName: clients.fullName
    })
    .from(timesheetEntries)
    .leftJoin(shifts, eq(timesheetEntries.shiftId, shifts.id))
    .leftJoin(clients, eq(shifts.clientId, clients.id))
    .where(eq(timesheetEntries.timesheetId, timesheet[0].id))
    .orderBy(desc(timesheetEntries.entryDate));

  const totalHours = parseFloat(timesheet[0].totalHours || '0');
  const totalEarnings = parseFloat(timesheet[0].totalEarnings || '0');

  return {
    timesheet: timesheet[0],
    entries,
    totalHours,
    totalEarnings,
    periodStatus: 'current'
  };
}

export async function getTimesheetHistory(userId: number, tenantId: number): Promise<any[]> {
  const timesheetHistory = await db
    .select()
    .from(timesheets)
    .where(and(
      eq(timesheets.userId, userId),
      eq(timesheets.tenantId, tenantId)
    ))
    .orderBy(desc(timesheets.payPeriodStart));

  return timesheetHistory;
}

// Flexible break time calculation based on shift duration and type
function calculateBreakTime(totalMinutes: number, shiftData: any): number {
  // Standard Australian award: 30 minutes for shifts > 4 hours
  if (totalMinutes <= 240) return 0; // No break for shifts 4 hours or less
  
  // Check for shift-specific break overrides (future-proofing for enterprise agreements)
  if (shiftData.breakMinutes !== undefined) {
    return parseInt(shiftData.breakMinutes) || 0;
  }
  
  // Default break times based on shift duration
  if (totalMinutes > 480) return 60;  // 1 hour for 8+ hour shifts
  if (totalMinutes > 360) return 45;  // 45 minutes for 6-8 hour shifts
  return 30; // 30 minutes for 4-6 hour shifts
}

export async function createTimesheetEntryFromShift(shiftId: number): Promise<void> {
  // Get the completed shift details
  const shift = await db
    .select()
    .from(shifts)
    .where(eq(shifts.id, shiftId))
    .limit(1);

  if (!shift.length || !shift[0].startTime || !shift[0].endTime) {
    throw new Error("Shift not completed or missing start/end times");
  }

  const shiftData = shift[0];
  const userId = shiftData.userId;
  const tenantId = shiftData.tenantId;

  if (!userId) {
    throw new Error("Shift has no assigned user");
  }

  // Calculate hours worked - handle null values properly
  const startTimeValue = shiftData.startTime;
  const endTimeValue = shiftData.endTime;
  
  if (!startTimeValue || !endTimeValue) {
    throw new Error("Shift start and end times are required for timesheet calculation");
  }
  
  const startTime = new Date(startTimeValue);
  const endTime = new Date(endTimeValue);
  const totalMinutes = (endTime.getTime() - startTime.getTime()) / (1000 * 60);
  
  // Calculate break time based on shift duration and type with flexibility
  const breakMinutes = calculateBreakTime(totalMinutes, shiftData);
  const workedMinutes = Math.max(0, totalMinutes - breakMinutes);
  
  // Use integer math to prevent floating-point errors (convert to cents precision)
  const totalHoursCents = Math.round((workedMinutes / 60) * 100);
  const totalHours = totalHoursCents / 100;

  // Get hourly rate and calculate pay with integer math to prevent floating-point errors
  const hourlyRate = await getUserHourlyRate(userId, tenantId);
  const grossPayCents = Math.round(totalHours * hourlyRate * 100);
  const grossPay = grossPayCents / 100;

  // Find or create timesheet for the pay period
  const payPeriod = calculatePayPeriod(startTime);
  let timesheet = await findOrCreateTimesheet(userId, tenantId, payPeriod);

  // Check if entry already exists for this shift
  const existingEntry = await db
    .select()
    .from(timesheetEntries)
    .where(and(
      eq(timesheetEntries.timesheetId, timesheet.id),
      eq(timesheetEntries.shiftId, shiftId)
    ))
    .limit(1);

  if (existingEntry.length) {
    // Update existing entry
    await db
      .update(timesheetEntries)
      .set({
        startTime,
        endTime,
        breakMinutes,
        totalHours: String(totalHours),
        hourlyRate: String(hourlyRate),
        grossPay: String(grossPay)
      })
      .where(eq(timesheetEntries.id, existingEntry[0].id));
  } else {
    // Create new timesheet entry
    await db.insert(timesheetEntries).values({
      timesheetId: timesheet.id,
      shiftId,
      entryDate: startTime,
      startTime,
      endTime,
      breakMinutes,
      totalHours: String(totalHours),
      hourlyRate: String(hourlyRate),
      grossPay: String(grossPay),
      isAutoGenerated: true,
      notes: `Auto-generated from shift: ${shiftData.title}`
    });
  }

  // Update timesheet totals
  await updateTimesheetTotals(timesheet.id);
}

async function findOrCreateTimesheet(userId: number, tenantId: number, payPeriod: { start: Date; end: Date }) {
  try {
    // Try to find existing timesheet with specific field selection
    let timesheet = await db
      .select({
        id: timesheets.id,
        userId: timesheets.userId,
        tenantId: timesheets.tenantId,
        payPeriodStart: timesheets.payPeriodStart,
        payPeriodEnd: timesheets.payPeriodEnd,
        status: timesheets.status,
        totalHours: timesheets.totalHours,
        totalEarnings: timesheets.totalEarnings,
        totalTax: timesheets.totalTax,
        totalSuper: timesheets.totalSuper,
        netPay: timesheets.netPay,
        createdAt: timesheets.createdAt,
        updatedAt: timesheets.updatedAt
      })
      .from(timesheets)
      .where(and(
        eq(timesheets.userId, userId),
        eq(timesheets.tenantId, tenantId),
        eq(timesheets.payPeriodStart, payPeriod.start),
        eq(timesheets.payPeriodEnd, payPeriod.end)
      ))
      .limit(1);

    if (timesheet.length) {
      return timesheet[0];
    }

    // Create new timesheet
    const newTimesheet = await db.insert(timesheets).values({
      userId,
      tenantId,
      payPeriodStart: payPeriod.start,
      payPeriodEnd: payPeriod.end,
      status: 'draft',
      totalHours: '0',
      totalEarnings: '0',
      totalTax: '0',
      totalSuper: '0',
      netPay: '0'
    }).returning();

    return newTimesheet[0];
  } catch (error) {
    console.error('[TIMESHEET] Error in findOrCreateTimesheet:', error);
    throw new Error('Failed to create or find timesheet');
  }
}

async function updateTimesheetTotals(timesheetId: number): Promise<void> {
  // Get all entries for this timesheet
  const entries = await db
    .select()
    .from(timesheetEntries)
    .where(eq(timesheetEntries.timesheetId, timesheetId));

  const totalHours = entries.reduce((sum, entry) => sum + parseFloat(entry.totalHours || '0'), 0);
  const totalGrossPay = entries.reduce((sum, entry) => sum + parseFloat(entry.grossPay || '0'), 0);

  // Get timesheet to get user and tenant info
  const timesheet = await db
    .select()
    .from(timesheets)
    .where(eq(timesheets.id, timesheetId))
    .limit(1);

  if (!timesheet.length) return;

  // Calculate payroll with tax and super
  const payrollCalculation = await calculatePayroll(
    timesheet[0].userId,
    timesheet[0].tenantId,
    totalGrossPay,
    0  // ytdGross - starting fresh for each timesheet
  );

  // Update timesheet totals
  await db
    .update(timesheets)
    .set({
      totalHours: String(totalHours),
      totalEarnings: String(totalGrossPay),
      totalTax: String(payrollCalculation.taxWithheld),
      totalSuper: String(payrollCalculation.superContribution),
      netPay: String(payrollCalculation.netPay),
      updatedAt: new Date()
    })
    .where(eq(timesheets.id, timesheetId));
}

async function getUserHourlyRate(userId: number, tenantId: number): Promise<number> {
  // Get user's pay scale level and point
  const user = await db
    .select({
      payLevel: users.payLevel,
      payPoint: users.payPoint,
      employmentType: users.employmentType
    })
    .from(users)
    .where(eq(users.id, userId))
    .limit(1);

  if (!user.length || !user[0].payLevel || !user[0].payPoint) {
    // Return minimum wage if no pay scale configured
    return 23.23;
  }

  // Get pay scale rate
  const payScale = await db
    .select()
    .from(payScales)
    .where(and(
      eq(payScales.tenantId, tenantId),
      eq(payScales.level, user[0].payLevel),
      eq(payScales.payPoint, user[0].payPoint),
      eq(payScales.employmentType, user[0].employmentType || 'fulltime')
    ))
    .limit(1);

  if (!payScale.length) {
    // Return minimum wage if no pay scale configured
    return 23.23;
  }

  return parseFloat(payScale[0].hourlyRate);
}

export async function submitTimesheet(timesheetId: number, userId: number): Promise<boolean> {
  // Verify timesheet belongs to user
  const timesheet = await db
    .select()
    .from(timesheets)
    .where(and(eq(timesheets.id, timesheetId), eq(timesheets.userId, userId)))
    .limit(1);

  if (!timesheet.length) {
    throw new Error("Timesheet not found or access denied");
  }

  // Check if timesheet has entries
  const entries = await db
    .select()
    .from(timesheetEntries)
    .where(eq(timesheetEntries.timesheetId, timesheetId));

  if (!entries.length) {
    throw new Error("Cannot submit empty timesheet");
  }

  // ALWAYS require admin approval for proper payroll workflow
  // No auto-approval - all timesheets must go through admin review
  const newStatus = 'submitted';
  const approvedAt = null;

  await db
    .update(timesheets)
    .set({
      status: newStatus,
      submittedAt: new Date(),
      approvedAt,
      updatedAt: new Date()
    })
    .where(eq(timesheets.id, timesheetId));

  return false; // Always returns false - no auto-approval, requires admin review
}

// Remove timesheet entry when shift is uncompleted (reversal flow)
export async function removeTimesheetEntryByShiftId(shiftId: number): Promise<void> {
  console.log(`[TIMESHEET REVERSAL] Removing timesheet entry for shift ${shiftId}`);
  
  // Get the timesheet entry to find the timesheet ID
  const entry = await db
    .select()
    .from(timesheetEntries)
    .where(eq(timesheetEntries.shiftId, shiftId))
    .limit(1);

  if (!entry.length) {
    console.log(`[TIMESHEET REVERSAL] No timesheet entry found for shift ${shiftId}`);
    return;
  }

  const timesheetId = entry[0].timesheetId;

  // Remove the entry
  await db
    .delete(timesheetEntries)
    .where(eq(timesheetEntries.shiftId, shiftId));

  // Recalculate timesheet totals
  await updateTimesheetTotals(timesheetId);
  
  console.log(`[TIMESHEET REVERSAL] Removed entry and recalculated totals for timesheet ${timesheetId}`);
}

export async function canAddManualEntry(userId: number, tenantId: number, entryDate: Date): Promise<boolean> {
  // Enhanced validation for manual entries
  const dayStart = new Date(entryDate);
  dayStart.setHours(0, 0, 0, 0);
  const dayEnd = new Date(entryDate);
  dayEnd.setHours(23, 59, 59, 999);

  // Check if there's a corresponding shift for this date
  const correspondingShift = await db
    .select()
    .from(shifts)
    .where(and(
      eq(shifts.userId, userId),
      eq(shifts.tenantId, tenantId),
      gte(shifts.startTime, dayStart),
      lte(shifts.startTime, dayEnd)
    ))
    .limit(1);

  // Prevent future date entries
  const today = new Date();
  today.setHours(23, 59, 59, 999);
  if (entryDate > today) {
    return false;
  }

  return correspondingShift.length > 0;
}